{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implementar Tratamento de Erros Explícito (%w) e corrigir avisos de errcheck",
        "description": "...",
        "details": "...",
        "testStrategy": "Unit testing with Go test framework",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Revisar chamadas de I/O adicionando contexto com fmt.Errorf('%w')",
            "description": "Verificar se as chamadas de I/O estão sendo feitas corretamente, adicionando contexto para os erros utilizando fmt.Errorf('%w'). Isso garantirá que os erros sejam capturados e tratados adequadamente.",
            "dependencies": [],
            "details": "Revisar as chamadas de I/O em todos os módulos afetados (ex: arquivo, yaml.Unmarshal, exec.Command). Incluir exemplos de uso correto de fmt.Errorf('...: %w', err) e instruções de validação. Testar com testes unitários simulando falhas de I/O.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Eliminar todos os avisos de errcheck e incluir testes de erro simulados",
            "description": "Remover todos os avisos de errcheck do código e adicionar testes de erro simulados para garantir que os erros sejam tratados adequadamente. Isso inclui a criação de casos de teste para simular diferentes tipos de erros.",
            "dependencies": [],
            "details": "Eliminar todos os avisos de errcheck do código e adicionar testes de erro simulados. Incluir instruções de como realizar essa tarefa e exemplos de uso correto de fmt.Errorf('...: %w', err). Testar com testes unitários e integração.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Refatorar Tratamento de Erros em Operações de I/O e Configuração",
            "description": "Implementar tratamento de erros explícito para melhorar a legibilidade do código e corrigir avisos de errcheck.",
            "dependencies": [],
            "details": "### Padrão Obrigatório de Tratamento de Erro\\nTodo erro retornado deve ser encapsulado com contexto usando `fmt.Errorf`. O padrão a ser seguido é:\\n\\tif err != nil { return fmt.Errorf(\"contexto da operação: %w\", err) }\\n\\n### Escopo da Tarefa\\n- **Tarefa 1 (I/O e Configuração):** Focar em todas as operações que envolvem leitura de arquivos, parsing de YAML (`yaml.Unmarshal`), e interações com o sistema de arquivos.\\n- **Tarefa 2 (Lógica de Comandos e Componentes):** Focar nos métodos de `Update()` e `View()` dos componentes Bubble Tea e na lógica de execução dos comandos Cobra.\\n\\n### Exemplo de Código (Antes e Depois)\\n- **Antes:** `if err != nil { return err }`\\n- **Depois:** `if err != nil { return fmt.Errorf(\"ao carregar configuração de %s: %w\", filePath, err) }`\\n\\n### Critérios de Aceitação\\n- [ ] O padrão `fmt.Errorf` com `%w` é aplicado em todo o escopo definido.\\n- [ ] O comando `errcheck ./...` não reporta mais erros para os pacotes modificados.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Refatorar Tratamento de Erros em Lógica de Comandos e Componentes",
            "description": "Implementar tratamento de erros explícito para melhorar a legibilidade do código e corrigir avisos de errcheck.",
            "dependencies": [],
            "details": "### Padrão Obrigatório de Tratamento de Erro\\nTodo erro retornado deve ser encapsulado com contexto usando `fmt.Errorf`. O padrão a ser seguido é:\\n\\tif err != nil { return fmt.Errorf(\"contexto da operação: %w\", err) }\\n\\n### Escopo da Tarefa\\n- **Tarefa 1 (I/O e Configuração):** Focar em todas as operações que envolvem leitura de arquivos, parsing de YAML (`yaml.Unmarshal`), e interações com o sistema de arquivos.\\n- **Tarefa 2 (Lógica de Comandos e Componentes):** Focar nos métodos de `Update()` e `View()` dos componentes Bubble Tea e na lógica de execução dos comandos Cobra.\\n\\n### Exemplo de Código (Antes e Depois)\\n- **Antes:** `if err != nil { return err }`\\n- **Depois:** `if err != nil { return fmt.Errorf(\"ao carregar configuração de %s: %w\", filePath, err) }`\\n\\n### Critérios de Aceitação\\n- [ ] O padrão `fmt.Errorf` com `%w` é aplicado em todo o escopo definido.\\n- [ ] O comando `errcheck ./...` não reporta mais erros para os pacotes modificados.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-03T21:53:24.878Z"
      },
      {
        "id": 2,
        "title": "Finalizar a lógica de Redimensionamento e Propagação de Foco no LayoutModel",
        "description": "...",
        "details": "...",
        "testStrategy": "Integration testing with Charm Ecosystem",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar a propagação de foco em TextArea",
            "description": "Desenvolver a lógica para propagar o foco da área de texto nos componentes do layoutmodel",
            "dependencies": [
              "2.1"
            ],
            "details": "Implementação de código e testes integrados para garantir a funcionalidade correta",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar a propagação de foco em Slider",
            "description": "Desenvolver a lógica para propagar o foco do slider nos componentes do layoutmodel",
            "dependencies": [
              "2.2"
            ],
            "details": "Implementação de código e testes integrados para garantir a funcionalidade correta",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar a propagação de foco em FilePicker",
            "description": "Desenvolver a lógica para propagar o foco do filepicker nos componentes do layoutmodel",
            "dependencies": [
              "2.3"
            ],
            "details": "Implementação de código e testes integrados para garantir a funcionalidade correta",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Definir a lógica de Update() para propagação de foco em TextArea",
            "description": "Implementar a lógica de update para o componente TextArea, garantindo que a mudança de foco não quebre interações existentes.",
            "dependencies": [],
            "details": "Implementar a lógica de update para o componente TextArea, garantindo que a mudança de foco não quebre interações existentes.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Definir a lógica de Update() para propagação de foco em Slider",
            "description": "Implementar a lógica de update para o componente Slider, garantindo que a mudança de foco não quebre interações existentes.",
            "dependencies": [],
            "details": "Implementar a lógica de update para o componente Slider, garantindo que a mudança de foco não quebre interações existentes.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Definir a lógica de Update() para propagação de foco em FilePicker",
            "description": "Implementar a lógica de update para o componente FilePicker, garantindo que a mudança de foco não quebre interações existentes.",
            "dependencies": [],
            "details": "Implementar a lógica de update para o componente FilePicker, garantindo que a mudança de foco não quebre interações existentes.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Tratamento do Redimensionamento da Janela (`tea.WindowSizeMsg`)",
            "description": "O modelo principal (container) captura a `tea.WindowSizeMsg` e recalcula as dimensões (largura/altura) para seus componentes filhos.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nTratamento do redimensionamento da janela\\n\\n### Requisitos Técnicos\\n- Tratar a `tea.WindowSizeMsg`\\n- Recalcular dimensões (largura/altura) para componentes filhos\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `tea.WindowSizeMsg`\\n\\n### Critérios de Aceitação\\n- A janela se redimensiona corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Renderização Responsiva dos Componentes",
            "description": "Os componentes filhos recebem as novas dimensões do pai (via `Update`) e usam esses valores em seus métodos `View` para se desenhar corretamente dentro dos limites.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nRenderização responsiva dos componentes\\n\\n### Requisitos Técnicos\\n- Receber as novas dimensões do pai via `Update`\\n- Usar essas dimensões em métodos `View`\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `Update` com novas dimensões\\n\\n### Critérios de Aceitação\\n- Os componentes se desenham corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implementação dos Métodos `Focus()` e `Blur()`",
            "description": "Definir o contrato para os componentes 'focáveis'. O que acontece quando `Focus()` é chamado? O que acontece em `Blur()`?",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nImplementação dos métodos `Focus()` e `Blur()`\\n\\n### Requisitos Técnicos\\n- Definir o contrato para componentes 'focáveis'\\n- Implementar `Focus()` e `Blur()`\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `Focus()` e `Blur()`\\n\\n### Critérios de Aceitação\\n- Os métodos se implementam corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Delegação de Foco Inicial e Gerenciamento de Estado",
            "description": "O modelo pai decide qual componente filho deve receber o foco inicial e chama seu método `Focus()`. O pai mantém o estado de qual filho está focado.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nDelegação de foco inicial e gerenciamento de estado\\n\\n### Requisitos Técnicos\\n- Decidir qual componente filho deve receber o foco inicial\\n- Chamar método `Focus()`\\n- Manter o estado de qual filho está focado\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `Focus()` no modelo pai\\n\\n### Critérios de Aceitação\\n- O foco é delegado corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Propagação de Foco via Teclado - `tea.KeyMsg`",
            "description": "O componente atualmente focado trata eventos de teclado (ex: `Tab`, `Shift+Tab`, setas) para decidir se a navegação é interna ou se o foco deve passar para outro componente.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nPropagação de foco via teclado - `tea.KeyMsg`\\n\\n### Requisitos Técnicos\\n- Tratar eventos de teclado\\n- Decidir se a navegação é interna ou externa\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `tea.KeyMsg`\\n\\n### Critérios de Aceitação\\n- A navegação é feita corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Comunicação de Troca de Foco - Filho -> Pai",
            "description": "O componente filho, ao receber um `Tab`, envia uma mensagem customizada para o modelo pai (ex: `msg.NextField{}`). O modelo pai, ao receber esta mensagem, chama `Blur()` no filho atual e `Focus()` no próximo filho da lista.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nComunicação de troca de foco - Filho -> Pai\\n\\n### Requisitos Técnicos\\n- Enviar mensagem customizada para o modelo pai\\n- Chamar `Blur()` no filho atual\\n- Chamar `Focus()` no próximo filho\\n\\n### Exemplo de Mensagem (Tea.Msg) Relevante\\n- `msg.NextField{}`\\n\\n### Critérios de Aceitação\\n- A troca de foco é feita corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 3,
        "title": "Definir e aplicar o Contrato rígido da Interface Component (View, IsValid, Value)",
        "description": "...",
        "details": "...",
        "testStrategy": "Unit testing with Go test framework",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Revisar e atualizar documentação e exemplos de código para alinhar com o contrato final",
            "description": "Verificar a documentação existente, identificar as alterações necessárias e implementá-las corretamente nos exemplos de código, garantindo que refletem fielmente o contrato atualizado.",
            "dependencies": [],
            "details": "Revisar a documentação do contrato rígido da Interface Component para identificar as alterações necessárias. Implementar essas alterações nos exemplos de código em Go, utilizando critérios de validação rigorosos. Garantir que os exemplos de código reflitam fielmente o contrato atualizado.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Verificar e corrigir implementações dos métodos obrigatórios em todos os componentes",
            "description": "Revisar as implementações dos métodos View(), IsValid() e Update() nos componentes, identificando e corrigindo quaisquer erros ou inconsistências.",
            "dependencies": [],
            "details": "Revisar a documentação do contrato rígido da Interface Component para entender os critérios de implementação. Utilizar um conjunto de testes unitários para validar o comportamento dos métodos View(), IsValid() e Update() nos componentes, garantindo que atendam aos critérios estabelecidos no contrato.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Definir e implementar os métodos obrigatórios (View(), IsValid(), Update(), Value())",
            "description": "Desenvolver e documentar os métodos View, IsValid, Update e Value para garantir a consistência do código em todo o projeto.",
            "dependencies": [],
            "details": "Implementar os métodos View(), IsValid(), Update() e Value() com exemplos de implementação em Go. Ajustar os componentes existentes para atender aos padrões do contrato rígido. Validar o contrato com testes unitários utilizando o framework Go test.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Atualizar a documentação e exemplos de código para refletir o contrato final",
            "description": "Atualizar a documentação e exemplos de código para garantir que todos os componentes estejam em conformidade com o contrato rígido da Interface Component.",
            "dependencies": [],
            "details": "Refatorar a documentação e exemplos de código para refletir os métodos obrigatórios (View(), IsValid(), Update(), Value()). Implementar instruções claras sobre como aplicar e validar o contrato em todos os componentes.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implementar/Finalizar TextArea, Slider, FilePicker, RadioGroup, Tabs",
        "description": "...",
        "details": "...",
        "testStrategy": "Unit testing with Go test framework",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar os componentes de interface",
            "description": "Implementar TextArea, Slider, FilePicker, RadioGroup e Tabs com consistência e qualidade.",
            "dependencies": [],
            "details": "Implementar os métodos obrigatórios View(), IsValid() e Update(). Utilizar os pacotes internal/components e internal/models. Exemplos de uso esperado: implementação de UIs personalizadas. Testes devem validar o comportamento dos componentes em diferentes cenários.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Epic: Implementação da Biblioteca de Componentes de UI Adicionais",
            "description": "Abrange o design e a implementação de cinco novos componentes interativos, com um contrato de interface comum para garantir consistência.",
            "dependencies": [],
            "details": "### Objetivo do Epic\nEnriquecer a biblioteca de UI do Shantilly com cinco novos componentes robustos, testados e consistentes, permitindo a criação de interfaces declarativas mais complexas.\n\n### Componentes no Escopo\n- [ ] `TextArea` (para entrada de texto de várias linhas)\n- [ ] `Slider` (para seleção de um valor numérico em um intervalo)\n- [ ] `FilePicker` (para navegação e seleção de arquivos no sistema)\n- [ ] `RadioGroup` (para seleção de uma única opção de uma lista)\n- [ ] `Tabs` (para organizar conteúdo em seções navegáveis)\n\n### Contrato de Componente Obrigatório\nTodo componente desenvolvido sob esta Epic DEVE implementar a seguinte interface para garantir a conformidade com o `LayoutModel`: \n- **`View() string`**: Deve retornar a representação em string do estado atual do componente para renderização.\n- **`Update(tea.Msg) (tea.Model, tea.Cmd)`**: Deve processar mensagens do Bubble Tea (como `tea.KeyMsg`) para atualizar seu estado interno e, opcionalmente, retornar comandos.\n- **`IsValid() bool`**: Deve retornar `true` se o estado atual do componente for válido de acordo com suas regras de negócio, e `false` caso contrário.\n- **`Value() interface{}`**: Deve retornar o valor principal do componente (o texto para `TextArea`, o número para `Slider`, etc.) em um formato serializável.\n\n### Próximos Passos\n- Criar tarefas individuais para cada um dos cinco componentes listados, vinculando-as a esta Epic.\n- Cada tarefa individual deve incluir a implementação da interface do contrato e testes unitários com mais de 85% de cobertura.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 5,
        "title": "Criar testes abrangentes para LayoutModel e Modelos de Orquestração (FormModel, MenuModel)",
        "description": "...",
        "details": "...",
        "testStrategy": "Integration testing with Charm Ecosystem",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Desenvolver abordagem de teste para FormModel",
            "description": "Implementar técnicas de teste para garantir a cobertura do FormModel, incluindo testes unitários e integração.",
            "dependencies": [],
            "details": "A abordagem de teste será baseada em testes unitários com o framework Go test, utilizando mocks e fixtures para garantir a cobertura do código.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar técnicas de teste para MenuModel",
            "description": "Desenvolver estratégias de teste para garantir a integridade do MenuModel, incluindo testes de performance e segurança.",
            "dependencies": [],
            "details": "A abordagem de teste será baseada em testes de performance com o framework Charm Ecosystem, utilizando técnicas de testes de segurança para garantir a proteção da aplicação.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desenvolver relatório de cobertura de testes",
            "description": "Criar um relatório detalhado das coberturas dos testes, incluindo resultados de testes unitários e integração.",
            "dependencies": [],
            "details": "O relatório será gerado com base nos resultados dos testes unitários e integração, utilizando ferramentas de análise de código para garantir a precisão das coberturas.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Definir estratégia de mocks/fixtures",
            "description": "Implementar uma abordagem eficaz para criar mocks e fixtures necessários para os testes integrados.",
            "dependencies": [],
            "details": "A estratégia deve ser baseada na documentação do LayoutModel e Modelos de Orquestração.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Validar estados de foco, entrada inválida e saída JSON da CLI",
            "description": "Implementar testes para verificar a correta implementação dos estados de foco e entrada inválida, bem como a saída JSON da CLI.",
            "dependencies": [],
            "details": "Os testes devem ser realizados com diferentes cenários e casos de teste.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Gerar relatórios de cobertura após execução dos testes",
            "description": "Implementar um sistema para gerar relatórios de cobertura após a execução dos testes integrados.",
            "dependencies": [
              "5.1"
            ],
            "details": "O sistema deve ser capaz de calcular e exibir a cobertura de testes com precisão.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Criar cenário de teste para validação da renderização do LayoutModel",
            "description": "Desenvolver um cenário de teste que valide a renderização do LayoutModel com componentes vazios, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Cenário de Teste (BDD)\n- **Given (Dado que):** O LayoutModel está configurado corretamente\n- **When (Quando):** O usuário executa uma ação que afeta a renderização do LayoutModel\n- **Then (Então):** A renderização do LayoutModel é válida e consistente com as expectativas.\n\n# Critérios de Aceitação\n- [ ] A renderização do LayoutModel é rápida e eficiente\n- [ ] O LayoutModel responde corretamente às ações do usuário",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Desenvolver critérios de aceitação para a validação da renderização do LayoutModel",
            "description": "Definir critérios claros e específicos para validar a renderização do LayoutModel, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Critérios de Aceitação\n- [ ] A renderização do LayoutModel é rápida e eficiente\n- [ ] O LayoutModel responde corretamente às ações do usuário\n\n# Informações Adicionais\n- **Tipo de Teste:** Teste Unitário",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implementar testes unitários para validar a renderização do LayoutModel",
            "description": "Desenvolver testes unitários que valide a renderização do LayoutModel, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Testes Unitários\n- **Teste 1:** Validar a renderização do LayoutModel com componentes vazios\n- **Teste 2:** Validar a renderização do LayoutModel com diferentes estilos de fontes",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Criar cenário de teste para validação da propagação de foco no LayoutModel",
            "description": "Desenvolver um cenário de teste que valide a propagação de foco no LayoutModel, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Cenário de Teste (BDD)\n- **Given (Dado que):** O usuário está no LayoutModel\n- **When (Quando):** O usuário executa uma ação que afeta a propagação de foco\n- **Then (Então):** A propagação de foco é válida e consistente com as expectativas.\n\n# Critérios de Aceitação\n- [ ] A propagação de foco é rápida e eficiente",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Desenvolver critérios de aceitação para a validação da propagação de foco no LayoutModel",
            "description": "Definir critérios claros e específicos para validar a propagação de foco no LayoutModel, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Critérios de Aceitação\n- [ ] A propagação de foco é rápida e eficiente\n- [ ] O LayoutModel responde corretamente às ações do usuário\n\n# Informações Adicionais\n- **Tipo de Teste:** Teste Unitário",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implementar testes unitários para validar a propagação de foco no LayoutModel",
            "description": "Desenvolver testes unitários que valide a propagação de foco no LayoutModel, garantindo a consistência do layout.",
            "dependencies": [],
            "details": "# Testes Unitários\n- **Teste 1:** Validar a propagação de foco com diferentes estilos de fontes\n- **Teste 2:** Validar a propagação de foco com diferentes tamanhos de texto",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Atingir 85% de cobertura nos pacotes internal/components e internal/models",
        "description": "...",
        "details": "...",
        "testStrategy": "Unit testing with Go test framework",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Revisar e complementar testes unitários para atingir a meta de cobertura",
            "description": "Revisar os testes unitários nos pacotes internal/components e internal/models garantindo cobertura mínima de 85% e identificar lacunas de testes existentes, implementar novos casos cobrindo fluxos de erro e sucesso, garantir a integração com o framework de testes Go e utilizar ferramentas de cobertura para validar que a meta de 85% foi alcançada.",
            "dependencies": [],
            "details": "Para realizar essa tarefa, é necessário identificar as lacunas de testes existentes nos pacotes internal/components e internal/models. Em seguida, implementar novos casos unitários cobrindo fluxos de erro e sucesso. Além disso, garantir a integração com o framework de testes Go e utilizar ferramentas de cobertura para validar que a meta de 85% foi alcançada.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Epic: Atingir 85% de Cobertura de Testes nos Pacotes Core",
            "description": "Defina a estratégia para aumentar a confiabilidade do código através da medição, aumento e aplicação de uma política rigorosa de cobertura de testes.",
            "dependencies": [],
            "details": "\\n### Objetivo do Epic\\naumentar sistematicamente a cobertura de testes de unidade e integração para um mínimo de 85% nos pacotes ’internal/components’ e ’internal/models\",\\n\\n### Meta de Cobertura\\n- **Mínimo Obrigatório:** 85%\\n\\n### Estratégia de Cobertura\\n1.\\n\\t**Análise de Cobertura Atual:**\\n\\t\\tGerar um relatório de cobertura inicial para identificar os arquivos com a menor cobertura dentro dos pacotes alvo.\\n\\t\\tComando a ser usado: `go test -coverprofile=coverage.out ./internal/...`\\n\\t\\tComando para análise: `go tool cover -func=coverage.out`\\n2.\\n\\t**Áreas Prioritárias para Testes:**\\n\\t\\t\\t**Testes Unitários:** Focar na lógica de negócio dentro dos modelos (`internal/models`), e nos métodos `Update()`, `IsValid()` e `Value()` dos componentes de UI (`internal/components`).\\n\\t\\t\\t**Testes de Integração:** Garantir que a interação entre os modelos e os componentes está devidamente testada.\\n3.\\n\\t**Aplicação da Política de Qualidade:**\\n\\t\\tO pipeline de CI/CD deve ser configurado para executar o script de verificação de cobertura em cada pull request.\\n\\t\\tO build deve falhar (`exit 1`) se a cobertura nos pacotes especificados for inferior a 85%.\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implementar o subcomando shantilly serve (Wish Server) com Custom Renderers",
        "description": "...",
        "details": "...",
        "testStrategy": "Integration testing with Charm Ecosystem",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar Lipgloss para estilização consistente",
            "description": "Integrar com Lipgloss para estilização consistente entre CLI local e execução remota.",
            "dependencies": [],
            "details": "Implementar a integração com Lipgloss, garantindo que as estilizações sejam consistentes tanto na CLI local quanto na execução remota.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desenvolver testes unitários e de integração",
            "description": "Incluir testes unitários e de integração para validar renderização remota.",
            "dependencies": [],
            "details": "Escrever testes unitários e de integração para garantir que a renderização remota seja correta e consistente.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar detecção de perfis de cor e fundo escuro/claro",
            "description": "Detectar automaticamente perfis de cor e fundo escuro/claro (HasDarkBackground).",
            "dependencies": [],
            "details": "Implementar a lógica para detectar automaticamente os perfis de cor e fundo escuro/claro, garantindo que as estilizações sejam adaptadas às necessidades do usuário.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Estrutura do Comando `serve` e Servidor Wish Básico",
            "description": "Criar o arquivo cmd/serve.go, definir o novo cobra.Command para serve e adicionar o comando serve ao root.go.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nCriar a estrutura básica do servidor Wish para expor a aplicação TUI via SSH.\\n\\n### Requisitos Técnicos\\n- Criar o arquivo cmd/serve.go\\n- Definir o novo cobra.Command para serve\\n- Adicionar o comando serve ao root.go\\n- Implementar um servidor wish mínimo que escute em uma porta e aceite conexões, sem integrar o Bubble Tea.\\n\\n### Critérios de Aceitação\\n- O arquivo cmd/serve.go deve estar presente e funcionando corretamente\\n- O comando serve deve estar adicionado ao root.go\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integração do Bubble Tea",
            "description": "Importar o middleware bubbletea.Middleware da biblioteca Wish, passar o handler da sua aplicação Bubble Tea para o middleware e garantir que a interface TUI seja iniciada para o cliente.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nIntegrar o Bubble Tea com o servidor Wish para expor a aplicação TUI via SSH.\\n\\n### Requisitos Técnicos\\n- Importar o middleware bubbletea.Middleware da biblioteca Wish\\n- Passar o handler da sua aplicação Bubble Tea para o middleware\\n- Garantir que, ao conectar via SSH, a interface TUI do Shantilly seja iniciada para o cliente.\\n\\n### Critérios de Aceitação\\n- O middleware bubbletea.Middleware deve estar funcionando corretamente\\n- A interface TUI do Shantilly deve ser iniciada para o cliente ao conectar via SSH",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Configuração e Finalização",
            "description": "Adicionar flags ao comando serve para configurar a porta e o host, adicionar gerenciamento de chaves SSH e implementar um desligamento gracioso.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nFinalizar a configuração do servidor Wish para expor a aplicação TUI via SSH.\\n\\n### Requisitos Técnicos\\n- Adicionar flags ao comando serve para configurar a porta e o host\\n- Adicionar gerenciamento de chaves SSH\\n- Implementar um desligamento gracioso (graceful shutdown) ao receber sinais do SO\\n\\n### Critérios de Aceitação\\n- O comando serve deve estar configurado corretamente para a porta e o host\\n- O gerenciamento de chaves SSH deve estar funcionando corretamente\\n",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 8,
        "title": "Resolver e otimizar o timeout nos testes E2E/Integração (Injeção de tea.WithWindowSize)",
        "description": "...",
        "details": "...",
        "testStrategy": "Integration testing with Charm Ecosystem",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir parâmetros fixos de janela para consistência de snapshots",
            "description": "Implementar a definição de parâmetros fixos de janela para garantir a consistência dos snapshots, evitando variações desnecessárias e melhorando a precisão das integrações.",
            "dependencies": [],
            "details": "Utilizar o módulo tea.WithWindowSize para definir parâmetros fixos de janela, como largura e altura, para garantir a consistência dos snapshots. Isso ajudará a evitar variações desnecessárias e melhorar a precisão das integrações.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Ajustar testes existentes para usar WithWindowSize()",
            "description": "Revisar e ajustar os testes existentes para utilizar o módulo tea.WithWindowSize(), garantindo que os resultados sejam precisos e consistentes.",
            "dependencies": [],
            "details": "Revisar os testes existentes e ajustá-los para utilizar o módulo tea.WithWindowSize(). Isso garantirá que os resultados sejam precisos e consistentes, evitando variações desnecessárias.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Documentar a estratégia para evitar timeouts e falsos positivos",
            "description": "Criar documentação detalhada sobre a estratégia de teste utilizada para evitar timeouts e falsos positivos, garantindo que os resultados sejam confiáveis.",
            "dependencies": [],
            "details": "Criar documentação detalhada sobre a estratégia de teste utilizada para evitar timeouts e falsos positivos. Isso ajudará a garantir que os resultados sejam confiáveis e precisos.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Análise e Identificação de Testes Instáveis",
            "description": "Crie um título claro para cada etapa do processo de correção (ex: 'Etapa 1: Análise e Identificação de Testes Instáveis'). Escreva uma descrição com no mínimo 30 palavras, explicando o objetivo daquela subtarefa para tornar o conjunto de testes mais confiável e determinístico.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nAnalisar os testes E2E/Integração para identificar problemas de timeout e condições de corrida (race conditions).\\n\\n### Requisitos Técnicos\\n- Utilizar o comando de shell para executar os testes em loop até que uma falha ocorra (ex: \\`for i in {1..50}; do go test -race ./... || break; done\\`).\\n- Documentar os testes que falham.\\n\\n### Exemplo de Código ou Comando\\n\\n### Critérios de Aceitação\\n- A tarefa será concluída quando todos os testes forem identificados e documentados.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementação de Esperas Explícitas",
            "description": "Substituir esperas frágeis (como \\`time.Sleep\\`) por funções de espera robustas. Por exemplo, criar uma função helper \\`waitForServerReady(url, timeout)\\` que faz polling em um endpoint até receber um status 200 ou atingir o timeout.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nImplementar funções de espera robustas para os testes E2E/Integração.\\n\\n### Requisitos Técnicos\\n- Criar uma função helper \\`waitForServerReady(url, timeout)\\`.\\n- Utilizar a biblioteca \\`testify/assert\\` para implementar as funções de espera.\\n\\n### Exemplo de Código ou Comando\\n\\n### Critérios de Aceitação\\n- A tarefa será concluída quando todas as funções de espera forem implementadas corretamente.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Refatoração com Timeouts e \\`testify/assert\\`",
            "description": "Refatorar os testes identificados para usar a biblioteca \\`testify/assert`, especificamente a função \\`assert.Eventually\\`, que verifica uma condição repetidamente por um determinado período, tornando os testes assíncronos mais limpos e confiáveis.",
            "dependencies": [],
            "details": "\\n### Objetivo da Tarefa\\nRefatorar os testes E2E/Integração para usar a biblioteca \\`testify/assert\\`.\\n\\n### Requisitos Técnicos\\n- Utilizar a função \\`assert.Eventually\\` para refatorar os testes.\\n- Documentar as mudanças feitas nos testes.\\n\\n### Exemplo de Código ou Comando\\n\\n### Critérios de Aceitação\\n- A tarefa será concluída quando todos os testes forem refatorados corretamente.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9,
        "title": "Executar testes de integração final e gerar relatório de cobertura (85%+)",
        "description": "...",
        "details": "...",
        "testStrategy": "Integration testing with Charm Ecosystem",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar os testes de integração finais",
            "description": "Desenvolver e executar testes integrados para garantir a cobertura necessária de 85%+ nos pacotes internos, incluindo fluxos críticos de layout, componentes e modelos.",
            "dependencies": [],
            "details": "Implementar os testes de integração finais utilizando as ferramentas go test, testify e cobertura nativa do Go. Testar os seguintes pacotes: internal/components e internal/models. Gerar relatórios de cobertura para avaliar a adesão à meta de 85%+.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Executar testes de integração finais para garantir a consistência do código",
            "description": "Validar a robustez e a qualidade do projeto, executando todos os testes de integração e gerando um relatório para garantir que a cobertura de código atinja ou supere 85%",
            "dependencies": [],
            "details": "### Objetivo Principal\nGarantir que todos os componentes do sistema se comunicam corretamente e que a base de código possui uma cobertura de testes de no mínimo 85%, validando a robustez e a qualidade do projeto.\n\n### Escopo de Teste (Cenários Chave)\n- **1. Validação dos Comandos Cobra:** Testar a interface de linha de comando, incluindo subcomandos, flags e mensagens de erro.\n- **2. Consistência da TUI (Local vs. Remoto):** Executar os mesmos formulários nos modos local e remoto (SSH) para garantir que o comportamento seja idêntico.\n- **3. Integração da Configuração (YAML):** Verificar o carregamento e interpretação de arquivos de configuração válidos e inválidos.\n- **4. Validação da Saída e Códigos de Status:** Confirmar que a aplicação gera a saída esperada e encerra com os códigos de status corretos.\n\n### Geração do Relatório de Cobertura\n- Detalhar o comando a ser executado para rodar todos os testes e gerar o perfil de cobertura (ex: 'go test -coverprofile=coverage.out ./...').\n- Especificar como visualizar o relatório (ex: 'go tool cover -html=coverage.out')\n\n### Critérios de Aceitação para a Tarefa\n- [ ] Todos os cenários de teste de integração foram executados com sucesso.\n- [ ] O relatório de cobertura de testes foi gerado.\n- [ ] A cobertura de testes final é igual ou superior a 85%.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 10,
        "title": "Atualizar a documentação do projeto com as novas funcionalidades e a arquitetura híbrida",
        "description": "...",
        "details": "...",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Revisar e atualizar a documentação do projeto com as novas funcionalidades e a arquitetura híbrida",
            "description": "Revisar a documentação existente e atualizá-la com as novas informações, garantindo que todas as mudanças de arquitetura e componentes sejam refletidas corretamente.",
            "dependencies": [],
            "details": "Descrever tecnicamente quais seções da documentação devem ser revisadas (CLI, Wish Server, Componentes), quais novos diagramas em Markdown precisam ser adicionados para explicar o fluxo CLI/Server e como garantir consistência entre documentação e código atual.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Atualizar a seção de Uso do README.md",
            "description": "Revisar e atualizar a seção de uso do README.md para incluir exemplos do novo comando serve.",
            "dependencies": [],
            "details": "\\n\\t- Revisar a seção de uso do README.md para garantir que ela esteja atualizada com as novas funcionalidades.\n\\t- Incluir exemplos do novo comando serve para ajudar os usuários a entender como usar o comando corretamente.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-03T21:53:24.879Z",
      "taskCount": 10,
      "completedCount": 0,
      "tags": [
        "master"
      ],
      "created": "2025-10-08T17:22:29.011Z",
      "description": "Tasks for master context",
      "updated": "2025-10-08T17:22:35.633Z"
    }
  }
}