
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>commands: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/helton/shantilly/cmd/shantilly/commands/form.go (0.0%)</option>
				
				<option value="file1">github.com/helton/shantilly/cmd/shantilly/commands/layout.go (0.0%)</option>
				
				<option value="file2">github.com/helton/shantilly/cmd/shantilly/commands/root.go (0.0%)</option>
				
				<option value="file3">github.com/helton/shantilly/cmd/shantilly/main.go (0.0%)</option>
				
				<option value="file4">github.com/helton/shantilly/internal/components/checkbox.go (71.8%)</option>
				
				<option value="file5">github.com/helton/shantilly/internal/components/factory.go (74.4%)</option>
				
				<option value="file6">github.com/helton/shantilly/internal/components/filepicker.go (32.3%)</option>
				
				<option value="file7">github.com/helton/shantilly/internal/components/radiogroup.go (79.5%)</option>
				
				<option value="file8">github.com/helton/shantilly/internal/components/slider.go (78.8%)</option>
				
				<option value="file9">github.com/helton/shantilly/internal/components/tabs.go (84.7%)</option>
				
				<option value="file10">github.com/helton/shantilly/internal/components/textarea.go (75.9%)</option>
				
				<option value="file11">github.com/helton/shantilly/internal/components/textinput.go (68.9%)</option>
				
				<option value="file12">github.com/helton/shantilly/internal/components/textlabel.go (55.6%)</option>
				
				<option value="file13">github.com/helton/shantilly/internal/config/app.go (0.0%)</option>
				
				<option value="file14">github.com/helton/shantilly/internal/config/manager.go (0.0%)</option>
				
				<option value="file15">github.com/helton/shantilly/internal/config/types.go (82.5%)</option>
				
				<option value="file16">github.com/helton/shantilly/internal/errors/errors.go (0.0%)</option>
				
				<option value="file17">github.com/helton/shantilly/internal/errors/middleware.go (0.0%)</option>
				
				<option value="file18">github.com/helton/shantilly/internal/models/app.go (0.0%)</option>
				
				<option value="file19">github.com/helton/shantilly/internal/models/form.go (45.9%)</option>
				
				<option value="file20">github.com/helton/shantilly/internal/models/layout.go (71.4%)</option>
				
				<option value="file21">github.com/helton/shantilly/internal/models/tabs.go (0.0%)</option>
				
				<option value="file22">github.com/helton/shantilly/internal/styles/theme.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package commands

import (
        "fmt"
        "os"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/models"
        "github.com/helton/shantilly/internal/styles"
        "github.com/spf13/cobra"
)

var formCmd = &amp;cobra.Command{
        Use:   "form [config.yaml]",
        Short: "Executa uma TUI de formulário interativo",
        Long: `Carrega um arquivo de configuração YAML e executa uma TUI de formulário
interativo. O resultado é serializado em JSON.`,
        Args: cobra.ExactArgs(1),
        RunE: runForm,
}

func runForm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        configPath := args[0]

        // Load configuration with explicit error handling
        cfg, err := config.LoadFormConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao carregar configuração: %w", err)
        }</span>

        // Create theme
        <span class="cov0" title="0">theme := styles.DefaultTheme()

        // Create form model
        model, err := models.NewFormModel(cfg, theme)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao criar modelo do formulário: %w", err)
        }</span>

        // Create and run tea program
        <span class="cov0" title="0">p := tea.NewProgram(model, tea.WithAltScreen())

        finalModel, err := p.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao executar TUI: %w", err)
        }</span>

        // Check if form was submitted
        <span class="cov0" title="0">formModel, ok := finalModel.(*models.FormModel)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("erro interno: tipo de modelo inválido")
        }</span>

        <span class="cov0" title="0">if formModel.Submitted() </span><span class="cov0" title="0">{
                // Serialize to JSON
                jsonData, err := formModel.ToJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao serializar dados: %w", err)
                }</span>

                // Write to stdout
                <span class="cov0" title="0">if _, err := fmt.Fprintln(os.Stdout, string(jsonData)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao escrever saída JSON no stdout: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package commands

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/models"
        "github.com/helton/shantilly/internal/styles"
        "github.com/spf13/cobra"
)

var layoutCmd = &amp;cobra.Command{
        Use:   "layout [config.yaml]",
        Short: "Executa uma TUI com layout estruturado",
        Long: `Carrega um arquivo de configuração YAML e executa uma TUI com layout
horizontal ou vertical.`,
        Args: cobra.ExactArgs(1),
        RunE: runLayout,
}

func runLayout(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        configPath := args[0]

        // Load configuration with explicit error handling
        cfg, err := config.LoadLayoutConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao carregar configuração: %w", err)
        }</span>

        // Create theme
        <span class="cov0" title="0">theme := styles.DefaultTheme()

        // Create layout model
        model, err := models.NewLayoutModel(cfg, theme)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao criar modelo do layout: %w", err)
        }</span>

        // Create and run tea program
        <span class="cov0" title="0">p := tea.NewProgram(model, tea.WithAltScreen())

        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro ao executar TUI de layout: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package commands

import (
        "fmt"

        "github.com/spf13/cobra"
)

const version = "0.1.0"

var rootCmd = &amp;cobra.Command{
        Use:   "shantilly",
        Short: "Construtor de TUI declarativo via YAML",
        Long: `Shantilly é uma ferramenta CLI moderna em Go que permite criar
Interfaces de Usuário de Terminal (TUI) ricas e interativas de forma
declarativa, utilizando arquivos de configuração YAML.

Construído sobre o ecossistema Charm (Bubble Tea, Lip Gloss, Bubbles).`,
        Version: version,
}

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Exibe a versão do Shantilly",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("Shantilly v%s\n", version)
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(formCmd)
        rootCmd.AddCommand(layoutCmd)
        // TODO: Add menu, tabs, serve commands
}</span>

// Execute runs the root command.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/helton/shantilly/cmd/shantilly/commands"
)

func main() <span class="cov0" title="0">{
        if err := commands.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erro: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// Checkbox implements a checkbox component.
// Note: bubbles/v2 doesn't have a checkbox yet, so we implement it with custom logic.
type Checkbox struct {
        name         string
        label        string
        required     bool
        help         string
        checked      bool
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialValue bool

        // Error management integration
        errorManager *errors.ErrorManager
}

// NewCheckbox creates a new Checkbox component from configuration.
func NewCheckbox(cfg config.ComponentConfig, theme *styles.Theme) (*Checkbox, error) <span class="cov10" title="21">{
        if cfg.Type != config.TypeCheckbox </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado checkbox, recebido %s", cfg.Type)
        }</span>

        <span class="cov9" title="20">c := &amp;Checkbox{
                name:     cfg.Name,
                label:    cfg.Label,
                required: cfg.Required,
                help:     cfg.Help,
                theme:    theme,
        }

        // Set default value if provided
        if cfg.Default != nil </span><span class="cov6" title="6">{
                if defaultBool, ok := cfg.Default.(bool); ok </span><span class="cov5" title="5">{
                        c.checked = defaultBool
                        c.initialValue = defaultBool
                }</span>
        }

        <span class="cov9" title="20">return c, nil</span>
}

// SetErrorManager configura o ErrorManager para o componente
func (c *Checkbox) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        c.errorManager = em
}</span>

// Init implements tea.Model.
func (c *Checkbox) Init() tea.Cmd <span class="cov3" title="2">{
        return nil
}</span>

// Update implements tea.Model.
func (c *Checkbox) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov6" title="6">{
        if !c.focused </span><span class="cov1" title="1">{
                return c, nil
        }</span>

        <span class="cov5" title="5">switch msg := msg.(type) </span>{
        // tea.KeyMsg is used for special keys, like space and enter.
        case tea.KeyMsg:<span class="cov5" title="4">
                switch msg.String() </span>{
                case " ", "space", "enter":<span class="cov4" title="3">
                        c.checked = !c.checked
                        c.errorMsg = ""</span>
                }
        }

        <span class="cov5" title="5">return c, nil</span>
}

// View implements tea.Model.
func (c *Checkbox) View() string <span class="cov5" title="4">{
        var b strings.Builder

        // Determine checkbox symbol
        var symbol string
        if c.checked </span><span class="cov1" title="1">{
                symbol = "[✓]"
        }</span> else<span class="cov4" title="3"> {
                symbol = "[ ]"
        }</span>

        // Build the checkbox line (without border - border is applied by layout)
        <span class="cov5" title="4">checkboxLine := symbol + " " + c.label
        b.WriteString(checkboxLine)

        // Render error message if present
        if c.errorMsg != "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(c.theme.Error.Render("✗ " + c.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov5" title="4">if c.help != "" &amp;&amp; c.errorMsg == "" </span><span class="cov4" title="3">{
                b.WriteString("\n")
                b.WriteString(c.theme.Help.Render(c.help))
        }</span>

        <span class="cov5" title="4">return b.String()</span>
}

// Name implements Component.
func (c *Checkbox) Name() string <span class="cov7" title="9">{
        return c.name
}</span>

// CanFocus implements Component.
func (c *Checkbox) CanFocus() bool <span class="cov3" title="2">{
        return true
}</span>

// SetFocus implements Component.
func (c *Checkbox) SetFocus(focused bool) <span class="cov7" title="9">{
        c.focused = focused
}</span>

// IsValid implements Component.
func (c *Checkbox) IsValid() bool <span class="cov8" title="11">{
        // For checkboxes, required means it must be checked
        if c.required &amp;&amp; !c.checked </span><span class="cov1" title="1">{
                c.errorMsg = "Esta opção deve ser marcada"

                if c.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Checkbox validation error in %s: opção obrigatória não marcada", c.name)
                }</span>
                <span class="cov1" title="1">return false</span>
        }

        <span class="cov7" title="10">c.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (c *Checkbox) GetError() string <span class="cov7" title="8">{
        return c.errorMsg
}</span>

// SetError implements Component.
func (c *Checkbox) SetError(msg string) <span class="cov6" title="6">{
        c.errorMsg = msg
}</span>

// Value implements Component.
func (c *Checkbox) Value() interface{} <span class="cov4" title="3">{
        return c.checked
}</span>

// SetValue implements Component.
func (c *Checkbox) SetValue(value interface{}) error <span class="cov9" title="15">{
        boolValue, ok := value.(bool)
        if !ok </span><span class="cov3" title="2">{
                err := fmt.Errorf("valor inválido: esperado bool, recebido %T", value)

                if c.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Checkbox type validation error in %s: tipo inválido", c.name)
                }</span>

                <span class="cov3" title="2">return err</span>
        }

        <span class="cov8" title="13">c.checked = boolValue

        // Clear any previous error when setting a valid value
        c.errorMsg = ""

        return nil</span>
}

// Reset implements Component.
func (c *Checkbox) Reset() <span class="cov3" title="2">{
        c.checked = c.initialValue
        c.errorMsg = ""
        c.focused = false
}</span>

// GetMetadata implements Component.
func (c *Checkbox) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Checkbox component for boolean selections",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Simple Checkbox",
                                Description: "Basic checkbox for accepting terms",
                                Config: map[string]interface{}{
                                        "type":     "checkbox",
                                        "name":     "accept_terms",
                                        "label":    "I accept the terms and conditions",
                                        "required": true,
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "boolean",
                                        "description": "The checkbox state",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (c *Checkbox) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov5" title="4">{
        var errors []ValidationError

        if !c.IsValid() </span><span class="cov0" title="0">{
                validationErr := ValidationError{
                        Code:     "VALIDATION_FAILED",
                        Message:  c.GetError(),
                        Field:    c.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":          "Checkbox",
                                "value":              c.Value(),
                                "validation_context": context,
                                "required":           c.required,
                                "checked":            c.checked,
                        },
                }
                errors = append(errors, validationErr)

                // Log to ErrorManager if available
                if c.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Checkbox validation failed in %s: %s", c.name, c.GetError())
                }</span>
        }

        <span class="cov5" title="4">return errors</span>
}

// ExportToFormat implements Component.
func (c *Checkbox) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     c.Name(),
                "value":    c.Value(),
                "metadata": c.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (c *Checkbox) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(bool); ok </span><span class="cov0" title="0">{
                return c.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (c *Checkbox) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (c *Checkbox) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        c.theme = theme
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package components

import (
        "fmt"
        "log"

        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// Global factory error manager for enhanced error handling
var factoryErrorManager *errors.ErrorManager

// SetFactoryErrorManager sets the global error manager for the factory
func SetFactoryErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        factoryErrorManager = em
}</span>

// NewComponent creates a component from configuration using the factory pattern.
// This ensures that all components are created consistently and with proper validation.
func NewComponent(cfg config.ComponentConfig, theme *styles.Theme) (Component, error) <span class="cov10" title="148">{
        // Enhanced configuration validation with ErrorManager integration
        if err := cfg.Validate(); err != nil </span><span class="cov4" title="7">{
                if factoryErrorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Factory component validation error for %s: %v", cfg.Name, err)
                }</span>
                <span class="cov4" title="7">return nil, fmt.Errorf("erro de validação da configuração: %w", err)</span>
        }

        // Component creation with enhanced error handling
        <span class="cov9" title="141">var component Component
        var err error

        switch cfg.Type </span>{
        case config.TypeTextInput:<span class="cov9" title="120">
                component, err = NewTextInput(cfg, theme)</span>
        case config.TypeTextArea:<span class="cov2" title="3">
                component, err = NewTextArea(cfg, theme)</span>
        case config.TypeCheckbox:<span class="cov3" title="5">
                component, err = NewCheckbox(cfg, theme)</span>
        case config.TypeRadioGroup:<span class="cov3" title="4">
                component, err = NewRadioGroup(cfg, theme)</span>
        case config.TypeSlider:<span class="cov3" title="5">
                component, err = NewSlider(cfg, theme)</span>
        case config.TypeText:<span class="cov2" title="3">
                component, err = NewTextLabel(cfg, theme)</span>
        case config.TypeFilePicker:<span class="cov1" title="1">
                component, err = NewFilePicker(cfg, theme)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("tipo de componente não suportado: %s", cfg.Type)</span>
        }

        // Enhanced error handling for component creation
        <span class="cov9" title="141">if err != nil </span><span class="cov2" title="3">{
                if factoryErrorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Factory component creation error for %s (%s): %v", cfg.Name, cfg.Type, err)
                }</span>
                <span class="cov2" title="3">return nil, fmt.Errorf("erro ao criar componente %s: %w", cfg.Name, err)</span>
        }

        // Set ErrorManager on components that support it
        <span class="cov9" title="138">if factoryErrorManager != nil </span><span class="cov0" title="0">{
                if textInput, ok := component.(*TextInput); ok </span><span class="cov0" title="0">{
                        textInput.SetErrorManager(factoryErrorManager)
                }</span>
                <span class="cov0" title="0">if textArea, ok := component.(*TextArea); ok </span><span class="cov0" title="0">{
                        textArea.SetErrorManager(factoryErrorManager)
                }</span>
        }

        <span class="cov9" title="138">return component, nil</span>
}

// NewComponents creates multiple components from a slice of configurations.
// Returns an error if any component fails to create, with enhanced error reporting.
func NewComponents(configs []config.ComponentConfig, theme *styles.Theme) ([]Component, error) <span class="cov7" title="32">{
        if len(configs) == 0 </span><span class="cov5" title="13">{
                return []Component{}, nil
        }</span>

        <span class="cov6" title="19">components := make([]Component, 0, len(configs))

        for i, cfg := range configs </span><span class="cov9" title="129">{
                comp, err := NewComponent(cfg, theme)
                if err != nil </span><span class="cov2" title="3">{
                        // Enhanced error reporting with context
                        if factoryErrorManager != nil </span><span class="cov0" title="0">{
                                log.Printf("Factory batch creation error at index %d: %v", i, err)
                        }</span>
                        <span class="cov2" title="3">return nil, fmt.Errorf("erro ao criar componente %d (%s): %w", i, cfg.Name, err)</span>
                }
                <span class="cov9" title="126">components = append(components, comp)</span>
        }

        // Success logging
        <span class="cov5" title="16">if factoryErrorManager != nil </span><span class="cov0" title="0">{
                log.Printf("Factory successfully created %d components", len(components))
        }</span>

        <span class="cov5" title="16">return components, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package components

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
)

// FilePickerState representa o estado interno do FilePicker
type FilePickerState struct {
        CurrentDir    string   `json:"current_dir"`
        SelectedFile  string   `json:"selected_file"`
        Files         []string `json:"files"`
        ShowHidden    bool     `json:"show_hidden"`
        FileFilter    string   `json:"file_filter"`
        ScrollOffset  int      `json:"scroll_offset"`
        CursorIndex   int      `json:"cursor_index"`
        Favorites     []string `json:"favorites"`
        History       []string `json:"history"`
        MaxHistory    int      `json:"max_history"`
        PreviewMode   bool     `json:"preview_mode"`
        PreviewBuffer string   `json:"preview_buffer"`
}

// FilePicker implements a file picker component for selecting files/directories.
// This component allows users to navigate through directories and select files.
type FilePicker struct {
        name         string
        label        string
        required     bool
        help         string
        selectedPath string
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialPath  string
        state        *FilePickerState
        width        int
        height       int
}

// NewFilePicker creates a new FilePicker component from configuration.
func NewFilePicker(cfg config.ComponentConfig, theme *styles.Theme) (*FilePicker, error) <span class="cov4" title="7">{
        if cfg.Type != config.TypeFilePicker </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado filepicker, recebido %s", cfg.Type)
        }</span>

        // Initialize state
        <span class="cov4" title="7">state := &amp;FilePickerState{
                CurrentDir:   ".",
                Files:        []string{},
                ShowHidden:   false,
                FileFilter:   "*",
                ScrollOffset: 0,
                CursorIndex:  0,
                Favorites:    []string{},
                History:      []string{},
                MaxHistory:   50,
                PreviewMode:  false,
        }

        fp := &amp;FilePicker{
                name:         cfg.Name,
                label:        cfg.Label,
                required:     cfg.Required,
                help:         cfg.Help,
                theme:        theme,
                state:        state,
                selectedPath: "",
                initialPath:  "",
                focused:      false,
                width:        80,
                height:       24,
        }

        // Set default path if provided
        if cfg.Default != nil </span><span class="cov0" title="0">{
                if defaultPath, ok := cfg.Default.(string); ok </span><span class="cov0" title="0">{
                        fp.selectedPath = defaultPath
                        fp.initialPath = defaultPath
                        fp.state.CurrentDir = defaultPath
                }</span>
        }

        // Set file filter if provided in options
        <span class="cov4" title="7">if cfg.Options != nil </span><span class="cov2" title="2">{
                if filter, ok := cfg.Options["filter"].(string); ok </span><span class="cov2" title="2">{
                        fp.state.FileFilter = filter
                }</span>
                <span class="cov2" title="2">if showHidden, ok := cfg.Options["show_hidden"].(bool); ok </span><span class="cov1" title="1">{
                        fp.state.ShowHidden = showHidden
                }</span>
                <span class="cov2" title="2">if maxHistory, ok := cfg.Options["max_history"].(int); ok </span><span class="cov1" title="1">{
                        fp.state.MaxHistory = maxHistory
                }</span>
                <span class="cov2" title="2">if previewMode, ok := cfg.Options["preview_mode"].(bool); ok </span><span class="cov1" title="1">{
                        fp.state.PreviewMode = previewMode
                }</span>
        }

        // Load initial directory
        <span class="cov4" title="7">if err := fp.loadDirectory(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail initialization - component can still function
                fp.errorMsg = fmt.Sprintf("Erro ao carregar diretório inicial: %v", err)
        }</span>

        <span class="cov4" title="7">return fp, nil</span>
}

// Init implements tea.Model.
func (fp *FilePicker) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (fp *FilePicker) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if !fp.focused </span><span class="cov0" title="0">{
                return fp, nil
        }</span>

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        fp.navigateUp()</span>
                case "down", "j":<span class="cov0" title="0">
                        fp.navigateDown()</span>
                case "left", "h", "backspace":<span class="cov0" title="0">
                        fp.navigateToParent()</span>
                case "right", "l", "enter":<span class="cov0" title="0">
                        fp.navigateInto()</span>
                case "home", "g":<span class="cov0" title="0">
                        fp.goToTop()</span>
                case "end", "G":<span class="cov0" title="0">
                        fp.goToBottom()</span>
                case "page up":<span class="cov0" title="0">
                        fp.pageUp()</span>
                case "page down":<span class="cov0" title="0">
                        fp.pageDown()</span>
                case " ":<span class="cov0" title="0">
                        fp.toggleSelection()</span>
                case "f":<span class="cov0" title="0">
                        fp.addToFavorites()</span>
                case "F":<span class="cov0" title="0">
                        fp.showFavorites()</span>
                case "p":<span class="cov0" title="0">
                        fp.togglePreview()</span>
                case "ctrl+c":<span class="cov0" title="0">
                        fp.focused = false
                        return fp, nil</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                fp.width = msg.Width
                fp.height = msg.Height</span>
        }

        <span class="cov0" title="0">return fp, nil</span>
}

// View implements tea.Model.
func (fp *FilePicker) View() string <span class="cov0" title="0">{
        var b strings.Builder

        // Header com informações básicas
        var header string
        if fp.selectedPath != "" </span><span class="cov0" title="0">{
                header = fmt.Sprintf("📁 %s", fp.selectedPath)
        }</span> else<span class="cov0" title="0"> {
                header = "📂 Nenhum arquivo selecionado"
        }</span>

        <span class="cov0" title="0">if fp.label != "" </span><span class="cov0" title="0">{
                header += fmt.Sprintf(" (%s)", fp.label)
        }</span>
        <span class="cov0" title="0">b.WriteString(fp.theme.Border.Render(header))
        b.WriteString("\n")

        // Renderizar lista de arquivos se estiver focado
        if fp.focused </span><span class="cov0" title="0">{
                fileList := fp.renderFileList()
                b.WriteString(fileList)
        }</span> else<span class="cov0" title="0"> {
                // Quando não focado, mostrar apenas informações básicas
                b.WriteString("Pressione Enter para navegar")
        }</span>

        // Render error message if present
        <span class="cov0" title="0">if fp.errorMsg != "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(fp.theme.Error.Render("✗ " + fp.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov0" title="0">if fp.help != "" &amp;&amp; fp.errorMsg == "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(fp.theme.Help.Render(fp.help))
        }</span>

        // Render contextual help quando focado
        <span class="cov0" title="0">if fp.focused &amp;&amp; fp.errorMsg == "" </span><span class="cov0" title="0">{
                contextualHelp := fp.getContextualHelp()
                if contextualHelp != "" </span><span class="cov0" title="0">{
                        b.WriteString("\n")
                        b.WriteString(fp.theme.Help.Render(contextualHelp))
                }</span>
        }

        <span class="cov0" title="0">return b.String()</span>
}

// Name implements Component.
func (fp *FilePicker) Name() string <span class="cov4" title="6">{
        return fp.name
}</span>

// CanFocus implements Component.
func (fp *FilePicker) CanFocus() bool <span class="cov1" title="1">{
        return true
}</span>

// SetFocus implements Component.
func (fp *FilePicker) SetFocus(focused bool) <span class="cov0" title="0">{
        fp.focused = focused
}</span>

// IsValid implements Component.
func (fp *FilePicker) IsValid() bool <span class="cov3" title="4">{
        errors := fp.ValidateWithContext(ValidationContext{
                ComponentValues: make(map[string]interface{}),
                GlobalConfig:    make(map[string]interface{}),
                ExternalData:    make(map[string]interface{}),
        })

        // Se há erros de validação, definir a primeira mensagem de erro
        if len(errors) &gt; 0 </span><span class="cov2" title="2">{
                fp.errorMsg = errors[0].Message
                return false
        }</span>

        <span class="cov2" title="2">fp.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (fp *FilePicker) GetError() string <span class="cov0" title="0">{
        return fp.errorMsg
}</span>

// SetError implements Component.
func (fp *FilePicker) SetError(msg string) <span class="cov0" title="0">{
        fp.errorMsg = msg
}</span>

// Value implements Component.
func (fp *FilePicker) Value() interface{} <span class="cov3" title="3">{
        return fp.selectedPath
}</span>

// SetValue implements Component.
func (fp *FilePicker) SetValue(value interface{}) error <span class="cov1" title="1">{
        strValue, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("valor inválido: esperado string, recebido %T", value)
        }</span>

        <span class="cov1" title="1">fp.selectedPath = strValue
        return nil</span>
}

// Reset implements Component.
func (fp *FilePicker) Reset() <span class="cov0" title="0">{
        fp.selectedPath = fp.initialPath
        fp.errorMsg = ""
        fp.focused = false
}</span>

// GetMetadata implements Component.
func (fp *FilePicker) GetMetadata() ComponentMetadata <span class="cov1" title="1">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "File picker component for selecting files and directories",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Config File Picker",
                                Description: "File picker for selecting configuration files",
                                Config: map[string]interface{}{
                                        "type":  "filepicker",
                                        "name":  "config_file",
                                        "label": "Select Configuration File",
                                        "options": map[string]interface{}{
                                                "filter": "*.yaml,*.yml,*.json",
                                        },
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "string",
                                        "description": "The selected file path",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (fp *FilePicker) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov4" title="8">{
        var errors []ValidationError

        // Validação básica: arquivo obrigatório deve estar selecionado
        if fp.required &amp;&amp; fp.selectedPath == "" </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Code:     "FILE_PICKER_REQUIRED",
                        Message:  "Um arquivo deve ser selecionado",
                        Field:    fp.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":   "FilePicker",
                                "value":       fp.Value(),
                                "current_dir": fp.state.CurrentDir,
                                "file_filter": fp.state.FileFilter,
                                "show_hidden": fp.state.ShowHidden,
                        },
                })
        }</span>

        // Validação: se há caminho selecionado, verificar se existe
        <span class="cov4" title="8">if fp.selectedPath != "" </span><span class="cov1" title="1">{
                if _, err := os.Stat(fp.selectedPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        errors = append(errors, ValidationError{
                                Code:     "FILE_NOT_FOUND",
                                Message:  "Arquivo selecionado não existe",
                                Field:    fp.name,
                                Severity: "error",
                                Context: map[string]interface{}{
                                        "component":   "FilePicker",
                                        "file_path":   fp.selectedPath,
                                        "current_dir": fp.state.CurrentDir,
                                },
                        })
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        // Outro erro de acesso ao arquivo
                        errors = append(errors, ValidationError{
                                Code:     "FILE_ACCESS_ERROR",
                                Message:  fmt.Sprintf("Erro ao acessar arquivo: %v", err),
                                Field:    fp.name,
                                Severity: "error",
                                Context: map[string]interface{}{
                                        "component": "FilePicker",
                                        "file_path": fp.selectedPath,
                                        "error":     err.Error(),
                                },
                        })
                }</span>
        }

        // Validação: verificar se diretório atual é acessível
        <span class="cov4" title="8">if _, err := os.Stat(fp.state.CurrentDir); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Code:     "CURRENT_DIR_ERROR",
                        Message:  fmt.Sprintf("Erro ao acessar diretório atual: %v", err),
                        Field:    fp.name,
                        Severity: "warning",
                        Context: map[string]interface{}{
                                "component":   "FilePicker",
                                "current_dir": fp.state.CurrentDir,
                                "error":       err.Error(),
                        },
                })
        }</span>

        // Validação cruzada: verificar se há componentes relacionados na validação
        <span class="cov4" title="8">if componentValues, exists := context.ComponentValues[fp.name]; exists </span><span class="cov0" title="0">{
                if relatedValue, ok := componentValues.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Pode adicionar validações cruzadas aqui no futuro
                        _ = relatedValue // Evitar erro de variável não utilizada
                }</span>
        }

        <span class="cov4" title="8">return errors</span>
}

// ExportToFormat implements Component.
func (fp *FilePicker) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov1" title="1">{
        data := map[string]interface{}{
                "name":     fp.Name(),
                "value":    fp.Value(),
                "metadata": fp.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (fp *FilePicker) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov1" title="1">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov1" title="1">if value, ok := imported["value"].(string); ok </span><span class="cov1" title="1">{
                return fp.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (fp *FilePicker) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (fp *FilePicker) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        fp.theme = theme
        // Re-renderizar lista de arquivos após mudança de tema
        if fp.focused &amp;&amp; len(fp.state.Files) &gt; 0 </span><span class="cov0" title="0">{
                if err := fp.loadDirectory(); err != nil </span><span class="cov0" title="0">{
                        fp.errorMsg = fmt.Sprintf("Erro ao recarregar diretório após mudança de tema: %v", err)
                }</span>
        }
}

// Métodos de navegação e funcionalidades avançadas do FilePicker

// loadDirectory carrega o conteúdo do diretório atual
func (fp *FilePicker) loadDirectory() error <span class="cov4" title="8">{
        files, err := os.ReadDir(fp.state.CurrentDir)
        if err != nil </span><span class="cov0" title="0">{
                fp.errorMsg = fmt.Sprintf("Erro ao ler diretório: %v", err)
                return err
        }</span>

        // Filtrar arquivos baseado nas configurações
        <span class="cov4" title="8">filteredFiles := []string{}
        for _, file := range files </span><span class="cov10" title="137">{
                name := file.Name()

                // Aplicar filtro de arquivos ocultos
                if !fp.state.ShowHidden &amp;&amp; strings.HasPrefix(name, ".") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Aplicar filtro de extensão se especificado
                <span class="cov10" title="137">if fp.state.FileFilter != "*" </span><span class="cov7" title="42">{
                        match, err := filepath.Match(fp.state.FileFilter, name)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="42">if !match </span><span class="cov2" title="2">{
                                continue</span>
                        }
                }

                <span class="cov9" title="135">filteredFiles = append(filteredFiles, name)</span>
        }

        <span class="cov4" title="8">fp.state.Files = filteredFiles

        // Adicionar diretório atual ao histórico se não estiver vazio
        if fp.state.CurrentDir != "" </span><span class="cov4" title="8">{
                fp.addToHistory(fp.state.CurrentDir)
        }</span>

        <span class="cov4" title="8">return nil</span>
}

// navigateUp move o cursor para cima na lista de arquivos
func (fp *FilePicker) navigateUp() <span class="cov1" title="1">{
        if fp.state.CursorIndex &gt; 0 </span><span class="cov1" title="1">{
                fp.state.CursorIndex--
                fp.updateScrollOffset()
        }</span>
}

// navigateDown move o cursor para baixo na lista de arquivos
func (fp *FilePicker) navigateDown() <span class="cov1" title="1">{
        if fp.state.CursorIndex &lt; len(fp.state.Files)-1 </span><span class="cov1" title="1">{
                fp.state.CursorIndex++
                fp.updateScrollOffset()
        }</span>
}

// navigateToParent navega para o diretório pai
func (fp *FilePicker) navigateToParent() <span class="cov0" title="0">{
        parentDir := filepath.Dir(fp.state.CurrentDir)
        if parentDir != fp.state.CurrentDir </span><span class="cov0" title="0">{ // Evitar loop infinito
                fp.state.CurrentDir = parentDir
                fp.state.CursorIndex = 0
                fp.state.ScrollOffset = 0
                if err := fp.loadDirectory(); err != nil </span><span class="cov0" title="0">{
                        fp.errorMsg = fmt.Sprintf("Erro ao navegar para diretório pai: %v", err)
                }</span>
        }
}

// navigateInto navega para dentro do diretório selecionado ou seleciona arquivo
func (fp *FilePicker) navigateInto() <span class="cov0" title="0">{
        if fp.state.CursorIndex &gt;= len(fp.state.Files) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">selected := fp.state.Files[fp.state.CursorIndex]
        fullPath := filepath.Join(fp.state.CurrentDir, selected)

        // Verificar se é diretório
        if info, err := os.Stat(fullPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                fp.state.CurrentDir = fullPath
                fp.state.CursorIndex = 0
                fp.state.ScrollOffset = 0
                if err := fp.loadDirectory(); err != nil </span><span class="cov0" title="0">{
                        fp.errorMsg = fmt.Sprintf("Erro ao navegar para diretório: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Selecionar arquivo
                fp.selectedPath = fullPath
                fp.errorMsg = ""
        }</span>
}

// goToTop vai para o primeiro arquivo da lista
func (fp *FilePicker) goToTop() <span class="cov0" title="0">{
        fp.state.CursorIndex = 0
        fp.updateScrollOffset()
}</span>

// goToBottom vai para o último arquivo da lista
func (fp *FilePicker) goToBottom() <span class="cov0" title="0">{
        fp.state.CursorIndex = len(fp.state.Files) - 1
        fp.updateScrollOffset()
}</span>

// pageUp navega uma página para cima
func (fp *FilePicker) pageUp() <span class="cov0" title="0">{
        pageSize := fp.getPageSize()
        fp.state.CursorIndex = max(0, fp.state.CursorIndex-pageSize)
        fp.updateScrollOffset()
}</span>

// pageDown navega uma página para baixo
func (fp *FilePicker) pageDown() <span class="cov0" title="0">{
        pageSize := fp.getPageSize()
        maxIndex := len(fp.state.Files) - 1
        fp.state.CursorIndex = min(maxIndex, fp.state.CursorIndex+pageSize)
        fp.updateScrollOffset()
}</span>

// toggleSelection alterna a seleção do arquivo atual
func (fp *FilePicker) toggleSelection() <span class="cov0" title="0">{
        if fp.state.CursorIndex &gt;= len(fp.state.Files) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">selected := fp.state.Files[fp.state.CursorIndex]
        fp.selectedPath = filepath.Join(fp.state.CurrentDir, selected)
        fp.errorMsg = ""</span>
}

// addToFavorites adiciona o diretório atual aos favoritos
func (fp *FilePicker) addToFavorites() <span class="cov2" title="2">{
        dir := fp.state.CurrentDir
        for _, favorite := range fp.state.Favorites </span><span class="cov1" title="1">{
                if favorite == dir </span><span class="cov1" title="1">{
                        return // Já está nos favoritos
                }</span>
        }
        <span class="cov1" title="1">fp.state.Favorites = append(fp.state.Favorites, dir)</span>
}

// showFavorites mostra apenas os diretórios favoritos
func (fp *FilePicker) showFavorites() <span class="cov0" title="0">{
        // Implementação simplificada - alterna entre favoritos e lista normal
        fp.state.ShowHidden = !fp.state.ShowHidden
        if err := fp.loadDirectory(); err != nil </span><span class="cov0" title="0">{
                fp.errorMsg = fmt.Sprintf("Erro ao mostrar favoritos: %v", err)
        }</span>
}

// togglePreview alterna o modo preview
func (fp *FilePicker) togglePreview() <span class="cov0" title="0">{
        fp.state.PreviewMode = !fp.state.PreviewMode
        if fp.state.PreviewMode &amp;&amp; fp.selectedPath != "" </span><span class="cov0" title="0">{
                fp.loadPreview()
        }</span>
}

// updateScrollOffset atualiza o offset de scroll para manter o cursor visível
func (fp *FilePicker) updateScrollOffset() <span class="cov2" title="2">{
        pageSize := fp.getPageSize()
        if fp.state.CursorIndex &lt; fp.state.ScrollOffset </span><span class="cov0" title="0">{
                fp.state.ScrollOffset = fp.state.CursorIndex
        }</span> else<span class="cov2" title="2"> if fp.state.CursorIndex &gt;= fp.state.ScrollOffset+pageSize </span><span class="cov0" title="0">{
                fp.state.ScrollOffset = fp.state.CursorIndex - pageSize + 1
        }</span>
}

// getPageSize retorna o tamanho da página baseado na altura disponível
func (fp *FilePicker) getPageSize() int <span class="cov2" title="2">{
        // Reservar espaço para header e footer
        availableHeight := fp.height - 4
        return max(1, availableHeight)
}</span>

// addToHistory adiciona um caminho ao histórico
func (fp *FilePicker) addToHistory(path string) <span class="cov5" title="11">{
        // Remover se já existir para evitar duplicatas
        for i, item := range fp.state.History </span><span class="cov4" title="6">{
                if item == path </span><span class="cov1" title="1">{
                        fp.state.History = append(fp.state.History[:i], fp.state.History[i+1:]...)
                        break</span>
                }
        }

        // Adicionar no início
        <span class="cov5" title="11">fp.state.History = append([]string{path}, fp.state.History...)

        // Limitar tamanho do histórico
        if len(fp.state.History) &gt; fp.state.MaxHistory </span><span class="cov0" title="0">{
                fp.state.History = fp.state.History[:fp.state.MaxHistory]
        }</span>
}

// loadPreview carrega preview do arquivo selecionado
func (fp *FilePicker) loadPreview() <span class="cov0" title="0">{
        if fp.selectedPath == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">file, err := os.Open(fp.selectedPath)
        if err != nil </span><span class="cov0" title="0">{
                fp.state.PreviewBuffer = fmt.Sprintf("Erro ao abrir arquivo: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fp.state.PreviewBuffer = fmt.Sprintf("Erro ao fechar arquivo: %v", closeErr)
                }</span>
        }()

        // Ler apenas primeiras linhas (máximo 20 linhas)
        <span class="cov0" title="0">scanner := bufio.NewScanner(file)
        lines := []string{}
        lineCount := 0
        maxLines := 20

        for scanner.Scan() &amp;&amp; lineCount &lt; maxLines </span><span class="cov0" title="0">{
                lines = append(lines, scanner.Text())
                lineCount++
        }</span>

        <span class="cov0" title="0">fp.state.PreviewBuffer = strings.Join(lines, "\n")

        if lineCount &gt;= maxLines </span><span class="cov0" title="0">{
                fp.state.PreviewBuffer += "\n... (arquivo muito grande para preview)"
        }</span>
}

// renderFileList renderiza a lista de arquivos
func (fp *FilePicker) renderFileList() string <span class="cov0" title="0">{
        var lines []string

        // Header com informações do diretório atual
        header := fmt.Sprintf("📁 %s", fp.state.CurrentDir)
        if fp.state.FileFilter != "*" </span><span class="cov0" title="0">{
                header += fmt.Sprintf(" (filtro: %s)", fp.state.FileFilter)
        }</span>
        <span class="cov0" title="0">lines = append(lines, fp.theme.Border.Render(header))

        pageSize := fp.getPageSize()
        endIndex := min(len(fp.state.Files), fp.state.ScrollOffset+pageSize)

        for i := fp.state.ScrollOffset; i &lt; endIndex; i++ </span><span class="cov0" title="0">{
                fileName := fp.state.Files[i]

                // Verificar se é diretório
                fullPath := filepath.Join(fp.state.CurrentDir, fileName)
                if info, err := os.Stat(fullPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                        fileName = "📁 " + fileName
                }</span> else<span class="cov0" title="0"> {
                        fileName = "📄 " + fileName
                }</span>

                // Aplicar estilo baseado no estado
                <span class="cov0" title="0">var styledLine string
                if i == fp.state.CursorIndex </span><span class="cov0" title="0">{
                        styledLine = fp.theme.BorderActive.Render("▶ " + fileName)
                }</span> else<span class="cov0" title="0"> {
                        styledLine = "  " + fileName
                }</span>

                <span class="cov0" title="0">lines = append(lines, styledLine)</span>
        }

        // Renderizar preview se habilitado
        <span class="cov0" title="0">if fp.state.PreviewMode &amp;&amp; fp.state.PreviewBuffer != "" </span><span class="cov0" title="0">{
                lines = append(lines, "")
                lines = append(lines, fp.theme.Border.Render("📖 Preview:"))
                previewLines := strings.Split(fp.state.PreviewBuffer, "\n")
                for _, line := range previewLines </span><span class="cov0" title="0">{
                        lines = append(lines, "  "+line)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// Funções auxiliares
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov2" title="2">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov2" title="2">return b</span>
}

// getContextualHelp retorna ajuda contextual baseada no estado atual
func (fp *FilePicker) getContextualHelp() string <span class="cov0" title="0">{
        help := "📋 Navegação: ↑↓ ou jk | ←→ ou hl | Enter: entrar/selecionar | "
        help += fmt.Sprintf("📁 Diretório: %s", fp.state.CurrentDir)

        if fp.state.FileFilter != "*" </span><span class="cov0" title="0">{
                help += fmt.Sprintf(" | 🔍 Filtro: %s", fp.state.FileFilter)
        }</span>

        <span class="cov0" title="0">if len(fp.state.Favorites) &gt; 0 </span><span class="cov0" title="0">{
                help += fmt.Sprintf(" | ⭐ Favoritos: %d", len(fp.state.Favorites))
        }</span>

        <span class="cov0" title="0">if fp.state.PreviewMode </span><span class="cov0" title="0">{
                help += " | 👁 Preview: ON"
        }</span>

        <span class="cov0" title="0">help += " | [Espaço]: selecionar | f: favoritar | p: preview | Ctrl+C: sair"

        return help</span>
}

// getCurrentDirectory returns the current working directory as a placeholder
// In a full implementation, this would maintain a current directory state
func (fp *FilePicker) getCurrentDirectory() string <span class="cov0" title="0">{
        if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                return dir
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// RadioItem represents a single radio button option.
type RadioItem struct {
        ID    string
        Label string
}

// RadioGroup implements a radio button group component with custom Lip Gloss rendering.
type RadioGroup struct {
        name         string
        label        string
        required     bool
        help         string
        items        []RadioItem
        cursor       int // Current cursor position
        selected     int // Selected item index (-1 = none)
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialValue int

        // Error management integration
        errorManager *errors.ErrorManager
}

// NewRadioGroup creates a new RadioGroup component from configuration.
func NewRadioGroup(cfg config.ComponentConfig, theme *styles.Theme) (*RadioGroup, error) <span class="cov8" title="23">{
        if cfg.Type != config.TypeRadioGroup </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado radiogroup, recebido %s", cfg.Type)
        }</span>

        // Parse items from options
        <span class="cov8" title="22">var items []RadioItem
        if cfg.Options != nil </span><span class="cov8" title="19">{
                if itemsData, ok := cfg.Options["items"].([]interface{}); ok </span><span class="cov8" title="19">{
                        for _, item := range itemsData </span><span class="cov10" title="39">{
                                if itemMap, ok := item.(map[string]interface{}); ok </span><span class="cov9" title="38">{
                                        id, okID := itemMap["id"].(string)
                                        if !okID </span><span class="cov2" title="2">{
                                                return nil, fmt.Errorf("campo 'id' deve ser string: %T", itemMap["id"])
                                        }</span>
                                        <span class="cov9" title="36">label, okLabel := itemMap["label"].(string)
                                        if !okLabel </span><span class="cov1" title="1">{
                                                return nil, fmt.Errorf("campo 'label' deve ser string: %T", itemMap["label"])
                                        }</span>
                                        <span class="cov9" title="35">if id != "" &amp;&amp; label != "" </span><span class="cov9" title="35">{
                                                items = append(items, RadioItem{ID: id, Label: label})
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="19">if len(items) == 0 </span><span class="cov4" title="5">{
                return nil, fmt.Errorf("radiogroup deve conter pelo menos um item")
        }</span>

        <span class="cov7" title="14">rg := &amp;RadioGroup{
                name:         cfg.Name,
                label:        cfg.Label,
                required:     cfg.Required,
                help:         cfg.Help,
                items:        items,
                cursor:       0,
                selected:     -1, // None selected by default
                theme:        theme,
                initialValue: -1,
        }

        // Set default value if provided
        if cfg.Default != nil </span><span class="cov2" title="2">{
                if defaultID, ok := cfg.Default.(string); ok </span><span class="cov1" title="1">{
                        for i, item := range items </span><span class="cov2" title="2">{
                                if item.ID == defaultID </span><span class="cov1" title="1">{
                                        rg.selected = i
                                        rg.initialValue = i
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="14">return rg, nil</span>
}

// SetErrorManager configura o ErrorManager para o componente
func (rg *RadioGroup) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        rg.errorManager = em
}</span>

// Init implements tea.Model.
func (rg *RadioGroup) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (rg *RadioGroup) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov6" title="11">{
        if !rg.focused </span><span class="cov1" title="1">{
                return rg, nil
        }</span>

        <span class="cov6" title="10">switch msg := msg.(type) </span>{
        case tea.KeyPressMsg:<span class="cov6" title="10">
                switch msg.Code </span>{
                case tea.KeyUp, 'k':<span class="cov3" title="3">
                        if rg.cursor &gt; 0 </span><span class="cov2" title="2">{
                                rg.cursor--
                        }</span>
                case tea.KeyDown, 'j':<span class="cov4" title="4">
                        if rg.cursor &lt; len(rg.items)-1 </span><span class="cov3" title="3">{
                                rg.cursor++
                        }</span>
                case tea.KeyEnter, tea.KeySpace:<span class="cov2" title="2">
                        rg.selected = rg.cursor
                        rg.errorMsg = ""</span>
                }
        }

        <span class="cov6" title="10">return rg, nil</span>
}

// View implements tea.Model.
func (rg *RadioGroup) View() string <span class="cov4" title="4">{
        var b strings.Builder

        // Render label
        if rg.label != "" </span><span class="cov4" title="4">{
                labelStyle := rg.theme.Label
                if rg.errorMsg != "" </span><span class="cov1" title="1">{
                        labelStyle = rg.theme.LabelError
                }</span>
                <span class="cov4" title="4">b.WriteString(labelStyle.Render(rg.label))
                b.WriteString("\n")</span>
        }

        // Render radio items
        <span class="cov4" title="4">for i, item := range rg.items </span><span class="cov7" title="12">{
                var symbol string
                var line string

                // Determine symbol based on selection
                if i == rg.selected </span><span class="cov3" title="3">{
                        symbol = "(•)"
                }</span> else<span class="cov6" title="9"> {
                        symbol = "( )"
                }</span>

                <span class="cov7" title="12">line = symbol + " " + item.Label

                // Apply style based on cursor position and focus
                if rg.focused &amp;&amp; i == rg.cursor </span><span class="cov2" title="2">{
                        line = rg.theme.RadioSelected.Render(line)
                }</span> else<span class="cov6" title="10"> if i == rg.selected </span><span class="cov3" title="3">{
                        line = rg.theme.RadioSelected.Render(line)
                }</span> else<span class="cov5" title="7"> {
                        line = rg.theme.RadioUnselected.Render(line)
                }</span>

                <span class="cov7" title="12">b.WriteString(line)
                if i &lt; len(rg.items)-1 </span><span class="cov6" title="8">{
                        b.WriteString("\n")
                }</span>
        }

        // Render error message if present
        <span class="cov4" title="4">if rg.errorMsg != "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(rg.theme.Error.Render("✗ " + rg.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov4" title="4">if rg.help != "" &amp;&amp; rg.errorMsg == "" </span><span class="cov3" title="3">{
                b.WriteString("\n")
                b.WriteString(rg.theme.Help.Render(rg.help))
        }</span>

        <span class="cov4" title="4">return b.String()</span>
}

// Name implements Component.
func (rg *RadioGroup) Name() string <span class="cov3" title="3">{
        return rg.name
}</span>

// CanFocus implements Component.
func (rg *RadioGroup) CanFocus() bool <span class="cov2" title="2">{
        return true
}</span>

// SetFocus implements Component.
func (rg *RadioGroup) SetFocus(focused bool) <span class="cov5" title="7">{
        rg.focused = focused
}</span>

// IsValid implements Component.
func (rg *RadioGroup) IsValid() bool <span class="cov5" title="6">{
        // Required validation: must have a selection
        if rg.required &amp;&amp; rg.selected == -1 </span><span class="cov2" title="2">{
                rg.errorMsg = "Selecione uma opção"

                if rg.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("RadioGroup validation error in %s: nenhuma opção selecionada", rg.name)
                }</span>
                <span class="cov2" title="2">return false</span>
        }

        <span class="cov4" title="4">rg.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (rg *RadioGroup) GetError() string <span class="cov6" title="8">{
        return rg.errorMsg
}</span>

// SetError implements Component.
func (rg *RadioGroup) SetError(msg string) <span class="cov4" title="5">{
        rg.errorMsg = msg
}</span>

// Value implements Component.
// Returns the ID of the selected item, not the index.
func (rg *RadioGroup) Value() interface{} <span class="cov3" title="3">{
        if rg.selected == -1 </span><span class="cov2" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return rg.items[rg.selected].ID</span>
}

// SetValue implements Component.
func (rg *RadioGroup) SetValue(value interface{}) error <span class="cov5" title="6">{
        idValue, ok := value.(string)
        if !ok </span><span class="cov2" title="2">{
                err := fmt.Errorf("valor inválido: esperado string (ID), recebido %T", value)

                if rg.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("RadioGroup type validation error in %s: tipo inválido", rg.name)
                }</span>

                <span class="cov2" title="2">return err</span>
        }

        // Find item by ID
        <span class="cov4" title="4">for i, item := range rg.items </span><span class="cov6" title="11">{
                if item.ID == idValue </span><span class="cov2" title="2">{
                        rg.selected = i
                        rg.cursor = i

                        // Clear any previous error when setting a valid value
                        rg.errorMsg = ""
                        return nil
                }</span>
        }

        <span class="cov2" title="2">err := fmt.Errorf("ID não encontrado: %s", idValue)

        if rg.errorManager != nil </span><span class="cov0" title="0">{
                log.Printf("RadioGroup ID not found error in %s: %v", rg.name, err)
        }</span>

        <span class="cov2" title="2">return err</span>
}

// Reset implements Component.
func (rg *RadioGroup) Reset() <span class="cov2" title="2">{
        rg.selected = rg.initialValue
        rg.cursor = 0
        if rg.initialValue != -1 </span><span class="cov1" title="1">{
                rg.cursor = rg.initialValue
        }</span>
        <span class="cov2" title="2">rg.errorMsg = ""
        rg.focused = false</span>
}

// GetMetadata implements Component.
func (rg *RadioGroup) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Radio button group component for single selections",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Color Selection",
                                Description: "Radio group for selecting a color",
                                Config: map[string]interface{}{
                                        "type":  "radiogroup",
                                        "name":  "color",
                                        "label": "Choose a color",
                                        "options": map[string]interface{}{
                                                "items": []map[string]interface{}{
                                                        {"id": "red", "label": "Red"},
                                                        {"id": "green", "label": "Green"},
                                                        {"id": "blue", "label": "Blue"},
                                                },
                                        },
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "string",
                                        "description": "The selected item ID",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (rg *RadioGroup) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        if !rg.IsValid() </span><span class="cov0" title="0">{
                validationErr := ValidationError{
                        Code:     "VALIDATION_FAILED",
                        Message:  rg.GetError(),
                        Field:    rg.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":          "RadioGroup",
                                "value":              rg.Value(),
                                "validation_context": context,
                                "required":           rg.required,
                                "selected":           rg.selected,
                                "cursor":             rg.cursor,
                                "total_items":        len(rg.items),
                        },
                }
                errors = append(errors, validationErr)

                // Log to ErrorManager if available
                if rg.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("RadioGroup validation failed in %s: %s", rg.name, rg.GetError())
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// ExportToFormat implements Component.
func (rg *RadioGroup) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     rg.Name(),
                "value":    rg.Value(),
                "metadata": rg.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (rg *RadioGroup) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(string); ok </span><span class="cov0" title="0">{
                return rg.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (rg *RadioGroup) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (rg *RadioGroup) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        rg.theme = theme
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// Slider implements a slider component with custom Lip Gloss rendering.
type Slider struct {
        name         string
        label        string
        required     bool
        help         string
        value        float64
        min          float64
        max          float64
        step         float64
        width        int
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialValue float64

        // Error management integration
        errorManager *errors.ErrorManager
}

// NewSlider creates a new Slider component from configuration.
func NewSlider(cfg config.ComponentConfig, theme *styles.Theme) (*Slider, error) <span class="cov10" title="17">{
        if cfg.Type != config.TypeSlider </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado slider, recebido %s", cfg.Type)
        }</span>

        <span class="cov9" title="16">s := &amp;Slider{
                name:     cfg.Name,
                label:    cfg.Label,
                required: cfg.Required,
                help:     cfg.Help,
                min:      0.0,
                max:      100.0,
                step:     1.0,
                width:    30,
                theme:    theme,
        }

        // Parse options
        if cfg.Options != nil </span><span class="cov7" title="9">{
                if min, ok := cfg.Options["min"].(float64); ok </span><span class="cov4" title="3">{
                        s.min = min
                }</span> else<span class="cov6" title="6"> if minInt, ok := cfg.Options["min"].(int); ok </span><span class="cov6" title="6">{
                        s.min = float64(minInt)
                }</span>

                <span class="cov7" title="9">if max, ok := cfg.Options["max"].(float64); ok </span><span class="cov4" title="3">{
                        s.max = max
                }</span> else<span class="cov6" title="6"> if maxInt, ok := cfg.Options["max"].(int); ok </span><span class="cov6" title="5">{
                        s.max = float64(maxInt)
                }</span>

                <span class="cov7" title="9">if step, ok := cfg.Options["step"].(float64); ok </span><span class="cov1" title="1">{
                        s.step = step
                }</span> else<span class="cov7" title="8"> if stepInt, ok := cfg.Options["step"].(int); ok </span><span class="cov3" title="2">{
                        s.step = float64(stepInt)
                }</span>

                <span class="cov7" title="9">if width, ok := cfg.Options["width"].(int); ok </span><span class="cov3" title="2">{
                        s.width = width
                }</span>
        }

        // Validate min/max
        <span class="cov9" title="16">if s.min &gt;= s.max </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("min deve ser menor que max")
        }</span>

        // Set default value
        <span class="cov9" title="14">s.value = s.min
        s.initialValue = s.min

        if cfg.Default != nil </span><span class="cov5" title="4">{
                if defaultFloat, ok := cfg.Default.(float64); ok </span><span class="cov1" title="1">{
                        if defaultFloat &gt;= s.min &amp;&amp; defaultFloat &lt;= s.max </span><span class="cov0" title="0">{
                                s.value = defaultFloat
                                s.initialValue = defaultFloat
                        }</span>
                } else<span class="cov4" title="3"> if defaultInt, ok := cfg.Default.(int); ok </span><span class="cov4" title="3">{
                        defaultFloat := float64(defaultInt)
                        if defaultFloat &gt;= s.min &amp;&amp; defaultFloat &lt;= s.max </span><span class="cov4" title="3">{
                                s.value = defaultFloat
                                s.initialValue = defaultFloat
                        }</span>
                }
        }

        <span class="cov9" title="14">return s, nil</span>
}

// SetErrorManager configura o ErrorManager para o componente
func (s *Slider) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        s.errorManager = em
}</span>

// Init implements tea.Model.
func (s *Slider) Init() tea.Cmd <span class="cov4" title="3">{
        return nil
}</span>

// Update implements tea.Model.
func (s *Slider) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov7" title="9">{
        if !s.focused </span><span class="cov1" title="1">{
                return s, nil
        }</span>

        <span class="cov7" title="8">switch msg := msg.(type) </span>{
        case tea.KeyPressMsg:<span class="cov7" title="8">
                switch msg.Code </span>{
                case tea.KeyLeft, 'h':<span class="cov4" title="3">
                        s.value -= s.step
                        if s.value &lt; s.min </span><span class="cov1" title="1">{
                                s.value = s.min
                        }</span>
                        <span class="cov4" title="3">s.errorMsg = ""</span>
                case tea.KeyRight, 'l':<span class="cov4" title="3">
                        s.value += s.step
                        if s.value &gt; s.max </span><span class="cov1" title="1">{
                                s.value = s.max
                        }</span>
                        <span class="cov4" title="3">s.errorMsg = ""</span>
                case tea.KeyHome:<span class="cov1" title="1">
                        s.value = s.min
                        s.errorMsg = ""</span>
                case tea.KeyEnd:<span class="cov1" title="1">
                        s.value = s.max
                        s.errorMsg = ""</span>
                }
        }

        <span class="cov7" title="8">return s, nil</span>
}

// View implements tea.Model.
func (s *Slider) View() string <span class="cov3" title="2">{
        var b strings.Builder

        // Render label
        if s.label != "" </span><span class="cov3" title="2">{
                labelStyle := s.theme.Label
                if s.errorMsg != "" </span><span class="cov1" title="1">{
                        labelStyle = s.theme.LabelError
                }</span>
                <span class="cov3" title="2">b.WriteString(labelStyle.Render(s.label))
                b.WriteString("\n")</span>
        }

        // Calculate position
        <span class="cov3" title="2">percentage := (s.value - s.min) / (s.max - s.min)
        filledWidth := int(float64(s.width) * percentage)
        if filledWidth &lt; 0 </span><span class="cov0" title="0">{
                filledWidth = 0
        }</span>
        <span class="cov3" title="2">if filledWidth &gt; s.width </span><span class="cov0" title="0">{
                filledWidth = s.width
        }</span>

        // Build slider bar
        <span class="cov3" title="2">filled := strings.Repeat("━", filledWidth)
        empty := strings.Repeat("━", s.width-filledWidth)

        // Apply styles to bar segments
        filledBar := s.theme.SliderFilled.Render(filled)
        emptyBar := s.theme.SliderBar.Render(empty)

        // Build slider line (without container border - border is applied by layout)
        sliderLine := filledBar + emptyBar + fmt.Sprintf(" %.1f", s.value)
        b.WriteString(sliderLine)
        b.WriteString("\n")

        // Render min/max labels
        rangeLabel := s.theme.Help.Render(fmt.Sprintf("Min: %.1f | Max: %.1f", s.min, s.max))
        b.WriteString(rangeLabel)

        // Render error message if present
        if s.errorMsg != "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(s.theme.Error.Render("✗ " + s.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov3" title="2">if s.help != "" &amp;&amp; s.errorMsg == "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(s.theme.Help.Render(s.help))
        }</span>

        <span class="cov3" title="2">return b.String()</span>
}

// Name implements Component.
func (s *Slider) Name() string <span class="cov7" title="7">{
        return s.name
}</span>

// CanFocus implements Component.
func (s *Slider) CanFocus() bool <span class="cov3" title="2">{
        return true
}</span>

// SetFocus implements Component.
func (s *Slider) SetFocus(focused bool) <span class="cov7" title="8">{
        s.focused = focused
}</span>

// IsValid implements Component.
func (s *Slider) IsValid() bool <span class="cov7" title="9">{
        // Slider is always valid since value is constrained by min/max
        s.errorMsg = ""
        return true
}</span>

// GetError implements Component.
func (s *Slider) GetError() string <span class="cov3" title="2">{
        return s.errorMsg
}</span>

// SetError implements Component.
func (s *Slider) SetError(msg string) <span class="cov4" title="3">{
        s.errorMsg = msg
}</span>

// Value implements Component.
func (s *Slider) Value() interface{} <span class="cov4" title="3">{
        return s.value
}</span>

// SetValue implements Component.
func (s *Slider) SetValue(value interface{}) error <span class="cov9" title="14">{
        var floatValue float64

        switch v := value.(type) </span>{
        case float64:<span class="cov4" title="3">
                floatValue = v</span>
        case int:<span class="cov8" title="10">
                floatValue = float64(v)</span>
        case int64:<span class="cov0" title="0">
                floatValue = float64(v)</span>
        default:<span class="cov1" title="1">
                err := fmt.Errorf("valor inválido: esperado número, recebido %T", value)

                if s.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Slider type validation error in %s: tipo inválido", s.name)
                }</span>

                <span class="cov1" title="1">return err</span>
        }

        <span class="cov9" title="13">if floatValue &lt; s.min || floatValue &gt; s.max </span><span class="cov3" title="2">{
                err := fmt.Errorf("valor fora do intervalo [%.1f, %.1f]", s.min, s.max)

                if s.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Slider range validation error in %s: valor fora do intervalo", s.name)
                }</span>

                <span class="cov3" title="2">return err</span>
        }

        <span class="cov8" title="11">s.value = floatValue

        // Clear any previous error when setting a valid value
        s.errorMsg = ""

        return nil</span>
}

// Reset implements Component.
func (s *Slider) Reset() <span class="cov3" title="2">{
        s.value = s.initialValue
        s.errorMsg = ""
        s.focused = false
}</span>

// GetMetadata implements Component.
func (s *Slider) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Slider component for numeric selections",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Volume Control",
                                Description: "Slider for volume control",
                                Config: map[string]interface{}{
                                        "type":  "slider",
                                        "name":  "volume",
                                        "label": "Volume",
                                        "options": map[string]interface{}{
                                                "min": 0,
                                                "max": 100,
                                        },
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "number",
                                        "description": "The slider value",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (s *Slider) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov5" title="4">{
        var errors []ValidationError

        if !s.IsValid() </span><span class="cov0" title="0">{
                validationErr := ValidationError{
                        Code:     "VALIDATION_FAILED",
                        Message:  s.GetError(),
                        Field:    s.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":          "Slider",
                                "value":              s.Value(),
                                "validation_context": context,
                                "required":           s.required,
                                "min":                s.min,
                                "max":                s.max,
                                "step":               s.step,
                        },
                }
                errors = append(errors, validationErr)

                // Log to ErrorManager if available
                if s.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("Slider validation failed in %s: %s", s.name, s.GetError())
                }</span>
        }

        <span class="cov5" title="4">return errors</span>
}

// ExportToFormat implements Component.
func (s *Slider) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     s.Name(),
                "value":    s.Value(),
                "metadata": s.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (s *Slider) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(float64); ok </span><span class="cov0" title="0">{
                return s.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (s *Slider) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (s *Slider) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        s.theme = theme
}</span>

// JoinHorizontal is a helper for lipgloss compatibility.
func joinHorizontal(parts ...string) string <span class="cov0" title="0">{
        return lipgloss.JoinHorizontal(lipgloss.Left, parts...)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
        "gopkg.in/yaml.v3"
)

// TabItem represents a single tab with its components.
type TabItem struct {
        Name       string
        Label      string
        Components []Component
}

// Tabs implements a tabs component that manages multiple tabs with their own components.
// This component orchestrates multiple components within tabs and handles tab navigation.
type Tabs struct {
        name       string
        label      string
        required   bool
        help       string
        tabs       []TabItem
        activeTab  int // Index of currently active tab
        theme      *styles.Theme
        errorMsg   string
        focused    bool
        initialTab int
}

// NewTabs creates a new Tabs component from configuration.
// This is different from other components as it needs to create child components for each tab.
func NewTabs(cfg config.TabsConfig, theme *styles.Theme) (*Tabs, error) <span class="cov8" title="17">{
        if len(cfg.Tabs) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tabs deve conter pelo menos uma aba")
        }</span>

        <span class="cov8" title="16">tabs := make([]TabItem, 0, len(cfg.Tabs))

        for _, tabCfg := range cfg.Tabs </span><span class="cov9" title="26">{
                // Create components for this tab using the factory
                components, err := NewComponents(tabCfg.Components, theme)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("erro ao criar componentes para aba %s: %w", tabCfg.Name, err)
                }</span>

                <span class="cov9" title="25">tabItem := TabItem{
                        Name:       tabCfg.Name,
                        Label:      tabCfg.Label,
                        Components: components,
                }

                tabs = append(tabs, tabItem)</span>
        }

        <span class="cov8" title="15">t := &amp;Tabs{
                name:       "tabs", // Tabs component has a fixed name
                label:      cfg.Title,
                required:   false, // Tabs itself doesn't have required validation
                help:       "",
                tabs:       tabs,
                activeTab:  0,
                theme:      theme,
                initialTab: 0,
        }

        return t, nil</span>
}

// Init implements tea.Model.
func (t *Tabs) Init() tea.Cmd <span class="cov3" title="3">{
        // Initialize all components in the active tab
        var cmds []tea.Cmd
        for _, comp := range t.tabs[t.activeTab].Components </span><span class="cov5" title="5">{
                cmds = append(cmds, comp.Init())
        }</span>
        <span class="cov3" title="3">return tea.Batch(cmds...)</span>
}

// Update implements tea.Model.
func (t *Tabs) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="16">{
        if !t.focused </span><span class="cov2" title="2">{
                // Even if not focused, propagate messages to active tab components
                // for non-focus messages like WindowSizeMsg
                if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov1" title="1">{
                        for i, comp := range t.tabs[t.activeTab].Components </span><span class="cov1" title="1">{
                                updated, cmd := comp.Update(msg)
                                if updatedModel, ok := updated.(Component); ok </span><span class="cov1" title="1">{
                                        t.tabs[t.activeTab].Components[i] = updatedModel
                                        return t, cmd
                                }</span>
                        }
                }
                <span class="cov1" title="1">return t, nil</span>
        }

        <span class="cov7" title="14">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov7" title="14">
                switch msg.String() </span>{
                case "left", "h":<span class="cov3" title="3">
                        if t.activeTab &gt; 0 </span><span class="cov2" title="2">{
                                t.activeTab--
                                t.updateActiveTab()
                        }</span>
                case "right", "l":<span class="cov3" title="3">
                        if t.activeTab &lt; len(t.tabs)-1 </span><span class="cov2" title="2">{
                                t.activeTab++
                                t.updateActiveTab()
                        }</span>
                case "tab":<span class="cov1" title="1">
                        // Tab navigation within the active tab
                        t.focusNextInActiveTab()
                        return t, nil</span>
                case "shift+tab":<span class="cov0" title="0">
                        // Reverse tab navigation within the active tab
                        t.focusPrevInActiveTab()
                        return t, nil</span>
                case "ctrl+tab":<span class="cov2" title="2">
                        // Ctrl+Tab: próxima aba
                        t.nextTab()
                        return t, nil</span>
                case "ctrl+shift+tab":<span class="cov2" title="2">
                        // Ctrl+Shift+Tab: aba anterior
                        t.prevTab()
                        return t, nil</span>
                case "ctrl+1", "ctrl+2", "ctrl+3", "ctrl+4", "ctrl+5", "ctrl+6", "ctrl+7", "ctrl+8", "ctrl+9":<span class="cov3" title="3">
                        // Ctrl+[número]: ir para aba específica
                        if num := int(msg.String()[5] - '0'); num &gt; 0 &amp;&amp; num &lt;= len(t.tabs) </span><span class="cov2" title="2">{
                                t.activeTab = num - 1
                                t.updateActiveTab()
                        }</span>
                        <span class="cov3" title="3">return t, nil</span>
                }
        }

        // Propagate message to focused component in active tab
        <span class="cov5" title="6">if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov5" title="6">{
                tab := &amp;t.tabs[t.activeTab]
                for i, comp := range tab.Components </span><span class="cov0" title="0">{
                        if comp.CanFocus() </span><span class="cov0" title="0">{
                                updated, cmd := comp.Update(msg)
                                if updatedModel, ok := updated.(Component); ok </span><span class="cov0" title="0">{
                                        tab.Components[i] = updatedModel
                                        return t, cmd
                                }</span>
                        }
                }
        }

        <span class="cov5" title="6">return t, nil</span>
}

// View implements tea.Model.
func (t *Tabs) View() string <span class="cov3" title="3">{
        var b strings.Builder

        // Render tab headers
        tabHeaders := t.renderTabHeaders()
        b.WriteString(tabHeaders)
        b.WriteString("\n")

        // Render active tab content
        if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov2" title="2">{
                activeTabContent := t.renderActiveTab()
                b.WriteString(activeTabContent)
        }</span>

        // Render error message if present
        <span class="cov3" title="3">if t.errorMsg != "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(t.theme.Error.Render("✗ " + t.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov3" title="3">if t.help != "" &amp;&amp; t.errorMsg == "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(t.theme.Help.Render(t.help))
        }</span>

        <span class="cov3" title="3">return b.String()</span>
}

// renderTabHeaders renders the tab navigation header.
func (t *Tabs) renderTabHeaders() string <span class="cov3" title="3">{
        return t.renderTabHeadersWithErrors()
}</span>

// renderActiveTab renders the content of the currently active tab.
func (t *Tabs) renderActiveTab() string <span class="cov2" title="2">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov2" title="2">tab := &amp;t.tabs[t.activeTab]
        var componentsView []string

        for i, comp := range tab.Components </span><span class="cov2" title="2">{
                view := comp.View()

                // Apply border based on focus state (similar to other models)
                if i == t.getFocusedComponentIndex() &amp;&amp; comp.CanFocus() </span><span class="cov2" title="2">{
                        view = t.theme.BorderActive.Render(view)
                }</span> else<span class="cov0" title="0"> {
                        view = t.theme.Border.Render(view)
                }</span>

                <span class="cov2" title="2">componentsView = append(componentsView, view)</span>
        }

        <span class="cov2" title="2">return lipgloss.JoinVertical(lipgloss.Left, componentsView...)</span>
}

// getFocusedComponentIndex returns the index of the currently focused component in the active tab.
func (t *Tabs) getFocusedComponentIndex() int <span class="cov2" title="2">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov2" title="2">tab := &amp;t.tabs[t.activeTab]
        for i, comp := range tab.Components </span><span class="cov2" title="2">{
                // This is a simplified approach - in a real implementation,
                // we'd need to track which component in which tab is focused
                if comp.CanFocus() </span><span class="cov2" title="2">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// focusNextInActiveTab moves focus to the next focusable component in the active tab.
func (t *Tabs) focusNextInActiveTab() <span class="cov1" title="1">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">tab := &amp;t.tabs[t.activeTab]
        for _, comp := range tab.Components </span><span class="cov1" title="1">{
                if comp.CanFocus() </span><span class="cov1" title="1">{
                        comp.SetFocus(true)
                        // In a real implementation, we'd track this index
                        break</span>
                }
        }
}

// focusPrevInActiveTab moves focus to the previous focusable component in the active tab.
func (t *Tabs) focusPrevInActiveTab() <span class="cov0" title="0">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tab := &amp;t.tabs[t.activeTab]
        for i := len(tab.Components) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if tab.Components[i].CanFocus() </span><span class="cov0" title="0">{
                        tab.Components[i].SetFocus(true)
                        // In a real implementation, we'd track this index
                        break</span>
                }
        }
}

// SetTheme implements Component.
func (t *Tabs) SetTheme(theme *styles.Theme) <span class="cov1" title="1">{
        t.theme = theme
        // Propagar mudança de tema para todos os componentes das abas
        for _, tab := range t.tabs </span><span class="cov1" title="1">{
                for _, comp := range tab.Components </span><span class="cov1" title="1">{
                        comp.SetTheme(theme)
                }</span>
        }
}

// Name implements Component.
func (t *Tabs) Name() string <span class="cov1" title="1">{
        return t.name
}</span>

// CanFocus implements Component.
func (t *Tabs) CanFocus() bool <span class="cov3" title="3">{
        return true
}</span>

// SetFocus implements Component.
func (t *Tabs) SetFocus(focused bool) <span class="cov6" title="8">{
        t.focused = focused
}</span>

// IsValid implements Component.
func (t *Tabs) IsValid() bool <span class="cov4" title="4">{
        errors := t.ValidateWithContext(ValidationContext{
                ComponentValues: make(map[string]interface{}),
                GlobalConfig:    make(map[string]interface{}),
                ExternalData:    make(map[string]interface{}),
        })

        // Se há erros de validação, definir a primeira mensagem de erro
        if len(errors) &gt; 0 </span><span class="cov2" title="2">{
                t.errorMsg = errors[0].Message
                return false
        }</span>

        <span class="cov2" title="2">t.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (t *Tabs) GetError() string <span class="cov4" title="4">{
        return t.errorMsg
}</span>

// ValidateWithContext implements Component.
func (t *Tabs) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov5" title="6">{
        var errors []ValidationError

        // Validar todas as abas e seus componentes
        for i, tab := range t.tabs </span><span class="cov6" title="10">{
                tabErrors := t.getTabErrors(i)

                // Adicionar erros de componentes individuais
                errors = append(errors, tabErrors...)

                // Validação específica da aba
                tabStatus := t.getTabValidationStatus(i)
                if !tabStatus.IsValid </span><span class="cov2" title="2">{
                        errors = append(errors, ValidationError{
                                Code:     "TAB_VALIDATION_FAILED",
                                Message:  fmt.Sprintf("Aba '%s' contém erros de validação", tab.Label),
                                Field:    fmt.Sprintf("tabs.%d", i),
                                Severity: "error",
                                Context: map[string]interface{}{
                                        "component":        "Tabs",
                                        "tab_name":         tab.Name,
                                        "tab_label":        tab.Label,
                                        "tab_index":        i,
                                        "valid_components": tabStatus.ValidComponents,
                                        "total_components": tabStatus.TotalComponents,
                                },
                        })
                }</span>
        }

        // Validação cruzada entre abas (exemplo)
        <span class="cov5" title="6">if len(t.tabs) &gt; 1 </span><span class="cov4" title="4">{
                // Verificar se há conflitos entre abas
                for i := 0; i &lt; len(t.tabs); i++ </span><span class="cov6" title="8">{
                        for j := i + 1; j &lt; len(t.tabs); j++ </span><span class="cov4" title="4">{
                                crossErrors := t.validateCrossTabDependencies(i, j, context)
                                errors = append(errors, crossErrors...)
                        }</span>
                }
        }

        <span class="cov5" title="6">return errors</span>
}

// validateCrossTabDependencies valida dependências entre abas
func (t *Tabs) validateCrossTabDependencies(tabIndex1, tabIndex2 int, context ValidationContext) []ValidationError <span class="cov4" title="4">{
        var errors []ValidationError

        // Exemplo de validação cruzada: verificar se há componentes relacionados
        tab1 := &amp;t.tabs[tabIndex1]
        tab2 := &amp;t.tabs[tabIndex2]

        // Verificar se há componentes com mesmo nome em abas diferentes (conflito potencial)
        for _, comp1 := range tab1.Components </span><span class="cov5" title="6">{
                for _, comp2 := range tab2.Components </span><span class="cov6" title="10">{
                        if comp1.Name() == comp2.Name() &amp;&amp; comp1.Value() != comp2.Value() </span><span class="cov1" title="1">{
                                // Encontrou componentes com mesmo nome mas valores diferentes
                                errors = append(errors, ValidationError{
                                        Code:     "CROSS_TAB_CONFLICT",
                                        Message:  fmt.Sprintf("Conflito entre abas: componente '%s' tem valores diferentes", comp1.Name()),
                                        Field:    fmt.Sprintf("tabs.%d.%s", tabIndex1, comp1.Name()),
                                        Severity: "warning",
                                        Context: map[string]interface{}{
                                                "component":      "Tabs",
                                                "tab1_name":      tab1.Name,
                                                "tab2_name":      tab2.Name,
                                                "component_name": comp1.Name(),
                                                "value1":         comp1.Value(),
                                                "value2":         comp2.Value(),
                                        },
                                })
                        }</span>
                }
        }

        <span class="cov4" title="4">return errors</span>
}

// SetError implements Component.
func (t *Tabs) SetError(msg string) <span class="cov3" title="3">{
        t.errorMsg = msg
}</span>

// Value implements Component.
// Returns a map with tab names as keys and component values as values.
func (t *Tabs) Value() interface{} <span class="cov4" title="4">{
        result := make(map[string]interface{})

        for _, tab := range t.tabs </span><span class="cov5" title="5">{
                tabData := make(map[string]interface{})
                for _, comp := range tab.Components </span><span class="cov5" title="6">{
                        tabData[comp.Name()] = comp.Value()
                }</span>
                <span class="cov5" title="5">result[tab.Name] = tabData</span>
        }

        <span class="cov4" title="4">return result</span>
}

// SetValue implements Component.
func (t *Tabs) SetValue(value interface{}) error <span class="cov3" title="3">{
        // This is a simplified implementation
        // In a real implementation, we'd need to properly distribute values to components
        _, ok := value.(map[string]interface{})
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("valor inválido: esperado map[string]interface{}, recebido %T", value)
        }</span>

        // TODO: Implement proper value setting for tabs
        <span class="cov2" title="2">return nil</span>
}

// Reset implements Component.
func (t *Tabs) Reset() <span class="cov1" title="1">{
        t.activeTab = t.initialTab
        t.errorMsg = ""
        t.focused = false

        // Reset all components in all tabs
        for _, tab := range t.tabs </span><span class="cov2" title="2">{
                for _, comp := range tab.Components </span><span class="cov2" title="2">{
                        comp.Reset()
                }</span>
        }
}

// Métodos avançados de navegação para Tabs

// updateActiveTab atualiza o estado quando a aba ativa muda
func (t *Tabs) updateActiveTab() <span class="cov6" title="10">{
        // Inicializar componentes da nova aba ativa
        if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov6" title="10">{
                var cmds []tea.Cmd
                for _, comp := range t.tabs[t.activeTab].Components </span><span class="cov4" title="4">{
                        cmds = append(cmds, comp.Init())
                }</span>
                // Retorna um batch command se necessário
                <span class="cov6" title="10">if len(cmds) &gt; 0 </span><span class="cov2" title="2">{
                        tea.Batch(cmds...)
                }</span>
        }
}

// nextTab vai para a próxima aba
func (t *Tabs) nextTab() <span class="cov2" title="2">{
        if t.activeTab &lt; len(t.tabs)-1 </span><span class="cov2" title="2">{
                t.activeTab++
        }</span> else<span class="cov0" title="0"> {
                t.activeTab = 0 // Volta para a primeira aba
        }</span>
        <span class="cov2" title="2">t.updateActiveTab()</span>
}

// prevTab vai para a aba anterior
func (t *Tabs) prevTab() <span class="cov2" title="2">{
        if t.activeTab &gt; 0 </span><span class="cov2" title="2">{
                t.activeTab--
        }</span> else<span class="cov0" title="0"> {
                t.activeTab = len(t.tabs) - 1 // Vai para a última aba
        }</span>
        <span class="cov2" title="2">t.updateActiveTab()</span>
}

// getTabErrors retorna erros da aba especificada
func (t *Tabs) getTabErrors(tabIndex int) []ValidationError <span class="cov9" title="25">{
        if tabIndex &lt; 0 || tabIndex &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return []ValidationError{}
        }</span>

        <span class="cov9" title="25">var errors []ValidationError
        tab := &amp;t.tabs[tabIndex]

        for _, comp := range tab.Components </span><span class="cov10" title="32">{
                compErrors := comp.ValidateWithContext(ValidationContext{
                        ComponentValues: make(map[string]interface{}),
                        GlobalConfig:    make(map[string]interface{}),
                        ExternalData:    make(map[string]interface{}),
                })

                errors = append(errors, compErrors...)
        }</span>

        <span class="cov9" title="25">return errors</span>
}

// renderTabHeadersWithErrors renderiza cabeçalhos com indicadores de erro
func (t *Tabs) renderTabHeadersWithErrors() string <span class="cov3" title="3">{
        var headers []string

        for i, tab := range t.tabs </span><span class="cov5" title="5">{
                var header string
                tabErrors := t.getTabErrors(i)

                // Tab label
                if i == t.activeTab </span><span class="cov2" title="2">{
                        header = t.theme.TabActive.Render(fmt.Sprintf(" %s ", tab.Label))
                }</span> else<span class="cov3" title="3"> {
                        header = t.theme.TabInactive.Render(fmt.Sprintf(" %s ", tab.Label))
                }</span>

                // Adicionar indicador de erro se houver
                <span class="cov5" title="5">if len(tabErrors) &gt; 0 </span><span class="cov0" title="0">{
                        errorIndicator := t.theme.Error.Render("⚠")
                        header = header + " " + errorIndicator
                }</span>

                <span class="cov5" title="5">headers = append(headers, header)</span>
        }

        <span class="cov3" title="3">return lipgloss.JoinHorizontal(lipgloss.Top, headers...)</span>
}

// getTabValidationStatus retorna o status de validação de uma aba
func (t *Tabs) getTabValidationStatus(tabIndex int) TabValidationStatus <span class="cov6" title="10">{
        if tabIndex &lt; 0 || tabIndex &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return TabValidationStatus{}
        }</span>

        <span class="cov6" title="10">tab := &amp;t.tabs[tabIndex]
        validComponents := 0
        totalComponents := len(tab.Components)

        for _, comp := range tab.Components </span><span class="cov7" title="14">{
                if comp.IsValid() </span><span class="cov7" title="12">{
                        validComponents++
                }</span>
        }

        <span class="cov6" title="10">return TabValidationStatus{
                TabIndex:        tabIndex,
                TabName:         tab.Name,
                TabLabel:        tab.Label,
                ValidComponents: validComponents,
                TotalComponents: totalComponents,
                IsValid:         validComponents == totalComponents,
                Errors:          t.getTabErrors(tabIndex),
        }</span>
}

// TabValidationStatus representa o status de validação de uma aba
type TabValidationStatus struct {
        TabIndex        int               `json:"tab_index"`
        TabName         string            `json:"tab_name"`
        TabLabel        string            `json:"tab_label"`
        ValidComponents int               `json:"valid_components"`
        TotalComponents int               `json:"total_components"`
        IsValid         bool              `json:"is_valid"`
        Errors          []ValidationError `json:"errors"`
}

// GetMetadata implements Component.
func (t *Tabs) GetMetadata() ComponentMetadata <span class="cov1" title="1">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Componente de abas para organização de múltiplos componentes",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Abas básicas",
                                Description: "Exemplo de configuração com múltiplas abas",
                                Config: map[string]interface{}{
                                        "title": "Configurações",
                                        "tabs": []map[string]interface{}{
                                                {
                                                        "name":  "geral",
                                                        "label": "Geral",
                                                        "components": []map[string]interface{}{
                                                                {"name": "host", "type": "textinput", "label": "Host"},
                                                        },
                                                },
                                        },
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "title": map[string]interface{}{"type": "string"},
                                "tabs": map[string]interface{}{
                                        "type": "array",
                                        "items": map[string]interface{}{
                                                "type": "object",
                                                "properties": map[string]interface{}{
                                                        "name":       map[string]interface{}{"type": "string"},
                                                        "label":      map[string]interface{}{"type": "string"},
                                                        "components": map[string]interface{}{"type": "array"},
                                                },
                                                "required": []string{"name", "label"},
                                        },
                                },
                        },
                        "required": []string{"tabs"},
                },
        }
}</span>

// ExportToFormat implements Component.
func (t *Tabs) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov1" title="1">{
        data := t.Value()
        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                return json.Marshal(data)</span>
        case FormatYAML:<span class="cov0" title="0">
                return yaml.Marshal(data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (t *Tabs) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov1" title="1">{
        var value interface{}
        switch format </span>{
        case FormatJSON:<span class="cov1" title="1">
                if err := json.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case FormatYAML:<span class="cov0" title="0">
                if err := yaml.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov1" title="1">return t.SetValue(value)</span>
}

// GetDependencies implements Component.
func (t *Tabs) GetDependencies() []string <span class="cov1" title="1">{
        var deps []string
        for _, tab := range t.tabs </span><span class="cov1" title="1">{
                for _, comp := range tab.Components </span><span class="cov1" title="1">{
                        compDeps := comp.GetDependencies()
                        deps = append(deps, compDeps...)
                }</span>
        }
        <span class="cov1" title="1">return deps</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"

        "github.com/charmbracelet/bubbles/v2/textarea"
        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// TextArea wraps bubbles/textarea and implements the Component interface.
// It provides a multi-line text input with validation support.
type TextArea struct {
        name         string
        label        string
        required     bool
        help         string
        model        textarea.Model
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialValue string

        // Validation options
        minLength int
        maxLength int

        // Error management integration
        errorManager *errors.ErrorManager
}

// NewTextArea creates a new TextArea component from configuration.
func NewTextArea(cfg config.ComponentConfig, theme *styles.Theme) (*TextArea, error) <span class="cov10" title="23">{
        if cfg.Type != config.TypeTextArea </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado textarea, recebido %s", cfg.Type)
        }</span>

        // Initialize bubbles textarea model
        <span class="cov9" title="22">ta := textarea.New()
        ta.Placeholder = cfg.Placeholder
        ta.ShowLineNumbers = false
        ta.CharLimit = 0 // No default limit

        // Set default value if provided
        if cfg.Default != nil </span><span class="cov4" title="3">{
                if defaultStr, ok := cfg.Default.(string); ok </span><span class="cov2" title="2">{
                        ta.SetValue(defaultStr)
                }</span>
        }

        <span class="cov9" title="22">t := &amp;TextArea{
                name:         cfg.Name,
                label:        cfg.Label,
                required:     cfg.Required,
                help:         cfg.Help,
                model:        ta,
                theme:        theme,
                initialValue: ta.Value(),
        }

        // Parse validation options
        if cfg.Options != nil </span><span class="cov5" title="5">{
                if minLen, ok := cfg.Options["min_length"].(int); ok </span><span class="cov4" title="3">{
                        t.minLength = minLen
                }</span>
                <span class="cov5" title="5">if maxLen, ok := cfg.Options["max_length"].(int); ok </span><span class="cov4" title="3">{
                        t.maxLength = maxLen
                        ta.CharLimit = maxLen
                }</span>
                <span class="cov5" title="5">if height, ok := cfg.Options["height"].(int); ok </span><span class="cov1" title="1">{
                        ta.SetHeight(height)
                }</span> else<span class="cov4" title="4"> {
                        ta.SetHeight(5) // Default height
                }</span>
                <span class="cov5" title="5">if width, ok := cfg.Options["width"].(int); ok </span><span class="cov1" title="1">{
                        ta.SetWidth(width)
                }</span> else<span class="cov4" title="4"> {
                        ta.SetWidth(50) // Default width
                }</span>
        }

        <span class="cov9" title="22">return t, nil</span>
}

// SetErrorManager configura o ErrorManager para o componente
func (t *TextArea) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        t.errorManager = em
}</span>

// Init implements tea.Model.
func (t *TextArea) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (t *TextArea) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov4" title="4">{
        var cmd tea.Cmd

        // Handle window size messages for responsive layout
        if wsMsg, ok := msg.(tea.WindowSizeMsg); ok </span><span class="cov1" title="1">{
                // Adjust width but preserve minimum
                newWidth := wsMsg.Width - 10
                if newWidth &lt; 30 </span><span class="cov0" title="0">{
                        newWidth = 30
                }</span>
                <span class="cov1" title="1">t.model.SetWidth(newWidth)</span>
        }

        // Only process input messages if focused
        <span class="cov4" title="4">if t.focused </span><span class="cov2" title="2">{
                t.model, cmd = t.model.Update(msg)
                // Clear error when user types
                if _, ok := msg.(tea.KeyPressMsg); ok </span><span class="cov1" title="1">{
                        t.errorMsg = ""
                }</span>
        }

        <span class="cov4" title="4">return t, cmd</span>
}

// View implements tea.Model.
func (t *TextArea) View() string <span class="cov4" title="3">{
        var b strings.Builder

        // Render label
        if t.label != "" </span><span class="cov2" title="2">{
                labelStyle := t.theme.Label
                if t.errorMsg != "" </span><span class="cov1" title="1">{
                        labelStyle = t.theme.LabelError
                }</span>
                <span class="cov2" title="2">b.WriteString(labelStyle.Render(t.label))
                b.WriteString("\n")</span>
        }

        // Render textarea (without border - border is applied by layout)
        <span class="cov4" title="3">b.WriteString(t.model.View())

        // Render error message if present
        if t.errorMsg != "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(t.theme.Error.Render("✗ " + t.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov4" title="3">if t.help != "" &amp;&amp; t.errorMsg == "" </span><span class="cov1" title="1">{
                b.WriteString("\n")
                b.WriteString(t.theme.Help.Render(t.help))
        }</span>

        <span class="cov4" title="3">return b.String()</span>
}

// Name implements Component.
func (t *TextArea) Name() string <span class="cov4" title="4">{
        return t.name
}</span>

// CanFocus implements Component.
func (t *TextArea) CanFocus() bool <span class="cov2" title="2">{
        return true
}</span>

// SetFocus implements Component.
func (t *TextArea) SetFocus(focused bool) <span class="cov6" title="7">{
        t.focused = focused
        if focused </span><span class="cov5" title="5">{
                t.model.Focus()
        }</span> else<span class="cov2" title="2"> {
                t.model.Blur()
        }</span>
}

// IsValid implements Component.
func (t *TextArea) IsValid() bool <span class="cov7" title="10">{
        value := t.model.Value()

        // Required validation with ErrorManager integration
        if t.required &amp;&amp; strings.TrimSpace(value) == "" </span><span class="cov2" title="2">{
                t.errorMsg = "Este campo é obrigatório"

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextArea validation error in %s: campo obrigatório não preenchido", t.name)
                }</span>
                <span class="cov2" title="2">return false</span>
        }

        // Skip other validations if empty and not required
        <span class="cov6" title="8">if value == "" </span><span class="cov4" title="3">{
                t.errorMsg = ""
                return true
        }</span>

        // Min length validation with ErrorManager integration
        <span class="cov5" title="5">if t.minLength &gt; 0 &amp;&amp; len(value) &lt; t.minLength </span><span class="cov1" title="1">{
                t.errorMsg = fmt.Sprintf("Mínimo de %d caracteres", t.minLength)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextArea min length validation error in %s: valor abaixo do mínimo", t.name)
                }</span>
                <span class="cov1" title="1">return false</span>
        }

        // Max length validation with ErrorManager integration
        <span class="cov4" title="4">if t.maxLength &gt; 0 &amp;&amp; len(value) &gt; t.maxLength </span><span class="cov1" title="1">{
                t.errorMsg = fmt.Sprintf("Máximo de %d caracteres", t.maxLength)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextArea max length validation error in %s: valor excede o máximo", t.name)
                }</span>
                <span class="cov1" title="1">return false</span>
        }

        // Clear error if validation passes
        <span class="cov4" title="3">t.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (t *TextArea) GetError() string <span class="cov8" title="14">{
        return t.errorMsg
}</span>

// SetError implements Component.
func (t *TextArea) SetError(msg string) <span class="cov6" title="7">{
        t.errorMsg = msg
}</span>

// Value implements Component.
func (t *TextArea) Value() interface{} <span class="cov6" title="8">{
        return t.model.Value()
}</span>

// SetValue implements Component.
func (t *TextArea) SetValue(value interface{}) error <span class="cov8" title="13">{
        strValue, ok := value.(string)
        if !ok </span><span class="cov1" title="1">{
                err := fmt.Errorf("valor inválido: esperado string, recebido %T", value)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextArea type validation error in %s: tipo inválido", t.name)
                }</span>

                <span class="cov1" title="1">return err</span>
        }

        <span class="cov8" title="12">t.model.SetValue(strValue)

        // Clear any previous error when setting a valid value
        t.errorMsg = ""

        return nil</span>
}

// Reset implements Component.
func (t *TextArea) Reset() <span class="cov2" title="2">{
        t.model.SetValue(t.initialValue)
        t.errorMsg = ""
        t.model.Blur()
        t.focused = false
}</span>

// GetMetadata implements Component.
func (t *TextArea) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Multi-line text area component with validation support",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Comment Field",
                                Description: "Multi-line text area for user comments",
                                Config: map[string]interface{}{
                                        "type":        "textarea",
                                        "name":        "comments",
                                        "label":       "Comments",
                                        "placeholder": "Enter your comments here...",
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "string",
                                        "description": "The text value",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (t *TextArea) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        // Basic validation with ErrorManager integration
        if !t.IsValid() </span><span class="cov0" title="0">{
                validationErr := ValidationError{
                        Code:     "VALIDATION_FAILED",
                        Message:  t.GetError(),
                        Field:    t.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":          "TextArea",
                                "value":              t.Value(),
                                "validation_context": context,
                                "required":           t.required,
                                "min_length":         t.minLength,
                                "max_length":         t.maxLength,
                        },
                }
                errors = append(errors, validationErr)

                // Log to ErrorManager if available
                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextArea validation failed in %s: %s", t.name, t.GetError())
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// ExportToFormat implements Component.
func (t *TextArea) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     t.Name(),
                "value":    t.Value(),
                "metadata": t.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (t *TextArea) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(string); ok </span><span class="cov0" title="0">{
                return t.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (t *TextArea) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (t *TextArea) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        t.theme = theme
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package components

import (
        "encoding/json"
        "fmt"
        "log"
        "regexp"
        "strings"

        "github.com/charmbracelet/bubbles/v2/textinput"
        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// TextInput wraps bubbles/textinput and implements the Component interface.
// It provides a single-line text input with validation support.
type TextInput struct {
        name         string
        label        string
        required     bool
        help         string
        model        textinput.Model
        theme        *styles.Theme
        errorMsg     string
        focused      bool
        initialValue string

        // Validation options
        minLength int
        maxLength int
        pattern   *regexp.Regexp

        // Error management integration
        errorManager *errors.ErrorManager
}

// NewTextInput creates a new TextInput component from configuration.
func NewTextInput(cfg config.ComponentConfig, theme *styles.Theme) (*TextInput, error) <span class="cov10" title="134">{
        if cfg.Type != config.TypeTextInput </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado textinput, recebido %s", cfg.Type)
        }</span>

        // Initialize bubbles textinput model
        <span class="cov9" title="133">ti := textinput.New()
        ti.Placeholder = cfg.Placeholder
        ti.CharLimit = 0 // No default limit

        // Set default value if provided
        if cfg.Default != nil </span><span class="cov2" title="2">{
                if defaultStr, ok := cfg.Default.(string); ok </span><span class="cov2" title="2">{
                        ti.SetValue(defaultStr)
                }</span>
        }

        <span class="cov9" title="133">t := &amp;TextInput{
                name:         cfg.Name,
                label:        cfg.Label,
                required:     cfg.Required,
                help:         cfg.Help,
                model:        ti,
                theme:        theme,
                initialValue: ti.Value(),
        }

        // Parse validation options
        if cfg.Options != nil </span><span class="cov2" title="2">{
                if minLen, ok := cfg.Options["min_length"].(int); ok </span><span class="cov1" title="1">{
                        t.minLength = minLen
                }</span>
                <span class="cov2" title="2">if maxLen, ok := cfg.Options["max_length"].(int); ok </span><span class="cov1" title="1">{
                        t.maxLength = maxLen
                        ti.CharLimit = maxLen
                }</span>
                <span class="cov2" title="2">if patternStr, ok := cfg.Options["pattern"].(string); ok </span><span class="cov0" title="0">{
                        pattern, err := regexp.Compile(patternStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erro ao compilar regex pattern: %w", err)
                        }</span>
                        <span class="cov0" title="0">t.pattern = pattern</span>
                }
        }

        <span class="cov9" title="133">return t, nil</span>
}

// SetErrorManager configura o ErrorManager para o componente
func (t *TextInput) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        t.errorManager = em
}</span>

// Init implements tea.Model.
func (t *TextInput) Init() tea.Cmd <span class="cov4" title="6">{
        return nil
}</span>

// Update implements tea.Model.
func (t *TextInput) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov3" title="4">{
        var cmd tea.Cmd

        // Only process messages if focused
        if t.focused </span><span class="cov1" title="1">{
                t.model, cmd = t.model.Update(msg)
                // Clear error when user types
                if _, ok := msg.(tea.KeyMsg); ok </span><span class="cov1" title="1">{
                        t.errorMsg = ""
                }</span>
        }

        <span class="cov3" title="4">return t, cmd</span>
}

// View implements tea.Model.
func (t *TextInput) View() string <span class="cov3" title="4">{
        var b strings.Builder

        // Render label
        if t.label != "" </span><span class="cov3" title="3">{
                labelStyle := t.theme.Label
                if t.errorMsg != "" </span><span class="cov0" title="0">{
                        labelStyle = t.theme.LabelError
                }</span>
                <span class="cov3" title="3">b.WriteString(labelStyle.Render(t.label))
                b.WriteString("\n")</span>
        }

        // Render input (without border - border is applied by layout)
        <span class="cov3" title="4">b.WriteString(t.model.View())

        // Render error message if present
        if t.errorMsg != "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(t.theme.Error.Render("✗ " + t.errorMsg))
        }</span>

        // Render help text if present and no error
        <span class="cov3" title="4">if t.help != "" &amp;&amp; t.errorMsg == "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(t.theme.Help.Render(t.help))
        }</span>

        <span class="cov3" title="4">return b.String()</span>
}

// Name implements Component.
func (t *TextInput) Name() string <span class="cov6" title="22">{
        return t.name
}</span>

// CanFocus implements Component.
func (t *TextInput) CanFocus() bool <span class="cov4" title="7">{
        return true
}</span>

// SetFocus implements Component.
func (t *TextInput) SetFocus(focused bool) <span class="cov3" title="5">{
        t.focused = focused
        if focused </span><span class="cov3" title="3">{
                t.model.Focus()
        }</span> else<span class="cov2" title="2"> {
                t.model.Blur()
        }</span>
}

// IsValid implements Component.
func (t *TextInput) IsValid() bool <span class="cov7" title="34">{
        value := t.model.Value()

        // Required validation
        if t.required &amp;&amp; strings.TrimSpace(value) == "" </span><span class="cov4" title="7">{
                t.errorMsg = "Este campo é obrigatório"

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        // Log validation error for debugging
                        log.Printf("TextInput validation error: Campo obrigatório não preenchido - %s", t.name)
                }</span>
                <span class="cov4" title="7">return false</span>
        }

        // Skip other validations if empty and not required
        <span class="cov7" title="27">if value == "" </span><span class="cov5" title="15">{
                t.errorMsg = ""
                return true
        }</span>

        // Min length validation
        <span class="cov5" title="12">if t.minLength &gt; 0 &amp;&amp; len(value) &lt; t.minLength </span><span class="cov1" title="1">{
                t.errorMsg = fmt.Sprintf("Mínimo de %d caracteres", t.minLength)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextInput min length validation error in %s: valor abaixo do mínimo", t.name)
                }</span>
                <span class="cov1" title="1">return false</span>
        }

        // Max length validation (already enforced by CharLimit, but check anyway)
        <span class="cov5" title="11">if t.maxLength &gt; 0 &amp;&amp; len(value) &gt; t.maxLength </span><span class="cov1" title="1">{
                t.errorMsg = fmt.Sprintf("Máximo de %d caracteres", t.maxLength)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextInput max length validation error in %s: valor excede o máximo", t.name)
                }</span>
                <span class="cov1" title="1">return false</span>
        }

        // Pattern validation
        <span class="cov5" title="10">if t.pattern != nil &amp;&amp; !t.pattern.MatchString(value) </span><span class="cov0" title="0">{
                t.errorMsg = "Formato inválido"

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextInput pattern validation error in %s: formato inválido", t.name)
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        // Clear error if validation passes
        <span class="cov5" title="10">t.errorMsg = ""
        return true</span>
}

// GetError implements Component.
func (t *TextInput) GetError() string <span class="cov5" title="12">{
        return t.errorMsg
}</span>

// SetError implements Component.
func (t *TextInput) SetError(msg string) <span class="cov2" title="2">{
        t.errorMsg = msg
}</span>

// Value implements Component.
func (t *TextInput) Value() interface{} <span class="cov6" title="18">{
        return t.model.Value()
}</span>

// SetValue implements Component.
func (t *TextInput) SetValue(value interface{}) error <span class="cov5" title="11">{
        strValue, ok := value.(string)
        if !ok </span><span class="cov1" title="1">{
                err := fmt.Errorf("valor inválido: esperado string, recebido %T", value)

                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextInput type validation error in %s: tipo inválido", t.name)
                }</span>

                <span class="cov1" title="1">return err</span>
        }

        <span class="cov5" title="10">t.model.SetValue(strValue)

        // Clear any previous error when setting a valid value
        t.errorMsg = ""

        return nil</span>
}

// Reset implements Component.
func (t *TextInput) Reset() <span class="cov3" title="3">{
        t.model.SetValue(t.initialValue)
        t.errorMsg = ""
        t.model.Blur()
        t.focused = false
}</span>

// GetMetadata implements Component.
func (t *TextInput) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Single-line text input component with validation support",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Simple Text Input",
                                Description: "Basic text input for user names",
                                Config: map[string]interface{}{
                                        "type":        "textinput",
                                        "name":        "username",
                                        "label":       "Username",
                                        "placeholder": "Enter your username",
                                        "required":    true,
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "string",
                                        "description": "The text value",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (t *TextInput) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov6" title="20">{
        var errors []ValidationError

        // Basic validation with ErrorManager integration
        if !t.IsValid() </span><span class="cov3" title="4">{
                validationErr := ValidationError{
                        Code:     "VALIDATION_FAILED",
                        Message:  t.GetError(),
                        Field:    t.name,
                        Severity: "error",
                        Context: map[string]interface{}{
                                "component":          "TextInput",
                                "value":              t.Value(),
                                "validation_context": context,
                        },
                }
                errors = append(errors, validationErr)

                // Log to ErrorManager if available (simplified for compilation)
                if t.errorManager != nil </span><span class="cov0" title="0">{
                        log.Printf("TextInput validation error in %s: %s", t.name, t.GetError())
                }</span>
        }

        // Cross-field validation examples with ErrorManager
        <span class="cov6" title="20">if componentValues, ok := context.ComponentValues["password"]; ok </span><span class="cov0" title="0">{
                if password, ok := componentValues.(string); ok &amp;&amp; t.name == "confirm_password" </span><span class="cov0" title="0">{
                        if currentValue := t.Value().(string); currentValue != password </span><span class="cov0" title="0">{
                                validationErr := ValidationError{
                                        Code:     "PASSWORD_MISMATCH",
                                        Message:  "Senhas não coincidem",
                                        Field:    t.name,
                                        Severity: "error",
                                        Context: map[string]interface{}{
                                                "component":       "TextInput",
                                                "related_field":   "password",
                                                "password_length": len(password),
                                                "current_length":  len(currentValue),
                                        },
                                }
                                errors = append(errors, validationErr)

                                // Log cross-field validation error (simplified for compilation)
                                if t.errorManager != nil </span><span class="cov0" title="0">{
                                        log.Printf("TextInput cross-field validation error in %s: senhas não coincidem", t.name)
                                }</span>
                        }
                }
        }

        <span class="cov6" title="20">return errors</span>
}

// ExportToFormat implements Component.
func (t *TextInput) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     t.Name(),
                "value":    t.Value(),
                "metadata": t.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (t *TextInput) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(string); ok </span><span class="cov0" title="0">{
                return t.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (t *TextInput) GetDependencies() []string <span class="cov1" title="1">{
        return []string{} // TextInput has no dependencies
}</span>

// SetTheme implements Component.
func (t *TextInput) SetTheme(theme *styles.Theme) <span class="cov1" title="1">{
        t.theme = theme
}</span>

// JoinVertical is a helper for lipgloss compatibility.
func joinVertical(parts ...string) string <span class="cov1" title="1">{
        return lipgloss.JoinVertical(lipgloss.Left, parts...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package components

import (
        "encoding/json"
        "fmt"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
)

// TextLabel implements a static text label component.
// This is used for displaying text that doesn't require user interaction.
type TextLabel struct {
        name  string
        text  string
        theme *styles.Theme
}

// NewTextLabel creates a new TextLabel component from configuration.
func NewTextLabel(cfg config.ComponentConfig, theme *styles.Theme) (*TextLabel, error) <span class="cov10" title="18">{
        if cfg.Type != config.TypeText </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tipo de componente inválido: esperado text, recebido %s", cfg.Type)
        }</span>

        <span class="cov9" title="17">text := cfg.Label
        if text == "" &amp;&amp; cfg.Default != nil </span><span class="cov3" title="2">{
                if defaultStr, ok := cfg.Default.(string); ok </span><span class="cov1" title="1">{
                        text = defaultStr
                }</span>
        }

        <span class="cov9" title="17">return &amp;TextLabel{
                name:  cfg.Name,
                text:  text,
                theme: theme,
        }, nil</span>
}

// Init implements tea.Model.
func (t *TextLabel) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (t *TextLabel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov5" title="4">{
        // Static component, no updates needed
        return t, nil
}</span>

// View implements tea.Model.
func (t *TextLabel) View() string <span class="cov5" title="4">{
        return t.theme.Label.Render(t.text) + "\n"
}</span>

// Name implements Component.
func (t *TextLabel) Name() string <span class="cov5" title="4">{
        return t.name
}</span>

// CanFocus implements Component.
func (t *TextLabel) CanFocus() bool <span class="cov4" title="3">{
        return false // Static component cannot receive focus
}</span>

// SetFocus implements Component.
func (t *TextLabel) SetFocus(focused bool) {<span class="cov6" title="5">
        // No-op for static component
}</span>

// IsValid implements Component.
func (t *TextLabel) IsValid() bool <span class="cov5" title="4">{
        return true // Static component is always valid
}</span>

// GetError implements Component.
func (t *TextLabel) GetError() string <span class="cov6" title="5">{
        return "" // Static component never has errors
}</span>

// SetError implements Component.
func (t *TextLabel) SetError(msg string) {<span class="cov4" title="3">
        // No-op for static component
}</span>

// Value implements Component.
func (t *TextLabel) Value() interface{} <span class="cov5" title="4">{
        return t.text
}</span>

// SetValue implements Component.
func (t *TextLabel) SetValue(value interface{}) error <span class="cov3" title="2">{
        strValue, ok := value.(string)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("valor inválido: esperado string, recebido %T", value)
        }</span>

        <span class="cov1" title="1">t.text = strValue
        return nil</span>
}

// Reset implements Component.
func (t *TextLabel) Reset() {<span class="cov4" title="3">
        // No-op for static component
}</span>

// GetMetadata implements Component.
func (t *TextLabel) GetMetadata() ComponentMetadata <span class="cov0" title="0">{
        return ComponentMetadata{
                Version:      "1.0.0",
                Author:       "Shantilly Team",
                Description:  "Static text label component for display-only text",
                Dependencies: []string{},
                Examples: []ComponentExample{
                        {
                                Name:        "Simple Label",
                                Description: "Basic static text label",
                                Config: map[string]interface{}{
                                        "type":  "text",
                                        "name":  "title",
                                        "label": "Welcome to Shantilly",
                                },
                        },
                },
                Schema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "value": map[string]interface{}{
                                        "type":        "string",
                                        "description": "The label text",
                                },
                        },
                },
        }
}</span>

// ValidateWithContext implements Component.
func (t *TextLabel) ValidateWithContext(context ValidationContext) []ValidationError <span class="cov0" title="0">{
        // Static component always passes validation
        return []ValidationError{}
}</span>

// ExportToFormat implements Component.
func (t *TextLabel) ExportToFormat(format ExportFormat) ([]byte, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":     t.Name(),
                "value":    t.Value(),
                "metadata": t.GetMetadata(),
        }

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("formato não suportado: %s", format)</span>
        }
}

// ImportFromFormat implements Component.
func (t *TextLabel) ImportFromFormat(format ExportFormat, data []byte) error <span class="cov0" title="0">{
        var imported map[string]interface{}

        switch format </span>{
        case FormatJSON:<span class="cov0" title="0">
                if err := json.Unmarshal(data, &amp;imported); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro ao fazer parse do JSON: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("formato não suportado: %s", format)</span>
        }

        <span class="cov0" title="0">if value, ok := imported["value"].(string); ok </span><span class="cov0" title="0">{
                return t.SetValue(value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDependencies implements Component.
func (t *TextLabel) GetDependencies() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// SetTheme implements Component.
func (t *TextLabel) SetTheme(theme *styles.Theme) <span class="cov0" title="0">{
        t.theme = theme
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "fmt"
        "time"
)

// Config represents the complete application configuration with hierarchical structure
type Config struct {
        Global      GlobalConfig           `yaml:"global" json:"global"`
        Forms       []FormConfig           `yaml:"forms,omitempty" json:"forms,omitempty"`
        Layouts     []LayoutConfig         `yaml:"layouts,omitempty" json:"layouts,omitempty"`
        Tabs        []TabsConfig           `yaml:"tabs,omitempty" json:"tabs,omitempty"`
        Menus       []MenuConfig           `yaml:"menus,omitempty" json:"menus,omitempty"`
        Themes      map[string]ThemeConfig `yaml:"themes,omitempty" json:"themes,omitempty"`
        Validation  ValidationConfig       `yaml:"validation,omitempty" json:"validation,omitempty"`
        Logging     LoggingConfig          `yaml:"logging,omitempty" json:"logging,omitempty"`
        Performance PerformanceConfig      `yaml:"performance,omitempty" json:"performance,omitempty"`
        Security    SecurityConfig         `yaml:"security,omitempty" json:"security,omitempty"`
}

// GlobalConfig contains global application configuration
type GlobalConfig struct {
        AppName      string            `yaml:"app_name" json:"app_name"`
        Version      string            `yaml:"version" json:"version"`
        Environment  string            `yaml:"environment" json:"environment"`
        Debug        bool              `yaml:"debug" json:"debug"`
        LogLevel     string            `yaml:"log_level" json:"log_level"`
        DefaultTheme string            `yaml:"default_theme" json:"default_theme"`
        DefaultView  string            `yaml:"default_view" json:"default_view"`
        Metadata     map[string]string `yaml:"metadata" json:"metadata"`
        BuildTime    time.Time         `yaml:"build_time" json:"build_time"`
        GitCommit    string            `yaml:"git_commit" json:"git_commit"`
}

// ThemeConfig contains theme configuration
type ThemeConfig struct {
        BaseTheme    string                    `yaml:"base_theme" json:"base_theme"`
        Extends      []string                  `yaml:"extends,omitempty" json:"extends,omitempty"`
        CustomStyles map[string]StyleConfig    `yaml:"custom_styles" json:"custom_styles"`
        ColorPalette ColorPalette              `yaml:"color_palette" json:"color_palette"`
        Font         FontConfig                `yaml:"font" json:"font"`
        Spacing      SpacingConfig             `yaml:"spacing" json:"spacing"`
        Components   map[string]ComponentStyle `yaml:"components" json:"components"`
}

// StyleConfig contains style configuration
type StyleConfig struct {
        Foreground string `yaml:"foreground" json:"foreground"`
        Background string `yaml:"background" json:"background"`
        Bold       bool   `yaml:"bold" json:"bold"`
        Italic     bool   `yaml:"italic" json:"italic"`
        Underline  bool   `yaml:"underline" json:"underline"`
}

// ColorPalette contains color palette configuration
type ColorPalette struct {
        Primary   string `yaml:"primary" json:"primary"`
        Secondary string `yaml:"secondary" json:"secondary"`
        Success   string `yaml:"success" json:"success"`
        Warning   string `yaml:"warning" json:"warning"`
        Error     string `yaml:"error" json:"error"`
        Info      string `yaml:"info" json:"info"`
}

// FontConfig contains font configuration
type FontConfig struct {
        Family string `yaml:"family" json:"family"`
        Size   int    `yaml:"size" json:"size"`
        Style  string `yaml:"style" json:"style"`
}

// SpacingConfig contains spacing configuration
type SpacingConfig struct {
        Margin  int `yaml:"margin" json:"margin"`
        Padding int `yaml:"padding" json:"padding"`
        Gap     int `yaml:"gap" json:"gap"`
}

// ComponentStyle contains component-specific styling
type ComponentStyle struct {
        Border       StyleConfig `yaml:"border" json:"border"`
        BorderActive StyleConfig `yaml:"border_active" json:"border_active"`
        Foreground   string      `yaml:"foreground" json:"foreground"`
        Background   string      `yaml:"background" json:"background"`
}

// ValidationConfig contains validation configuration
type ValidationConfig struct {
        Component  ComponentValidation  `yaml:"component" json:"component"`
        CrossField CrossFieldValidation `yaml:"cross_field" json:"cross_field"`
        Business   BusinessValidation   `yaml:"business" json:"business"`
        Schema     SchemaValidation     `yaml:"schema" json:"schema"`
}

// ComponentValidation contains component-level validation settings
type ComponentValidation struct {
        StrictMode bool `yaml:"strict_mode" json:"strict_mode"`
        RealTime   bool `yaml:"real_time" json:"real_time"`
        DebounceMs int  `yaml:"debounce_ms" json:"debounce_ms"`
}

// CrossFieldValidation contains cross-field validation settings
type CrossFieldValidation struct {
        Enabled          bool `yaml:"enabled" json:"enabled"`
        ValidateOnSubmit bool `yaml:"validate_on_submit" json:"validate_on_submit"`
}

// BusinessValidation contains business logic validation settings
type BusinessValidation struct {
        Enabled         bool   `yaml:"enabled" json:"enabled"`
        RulesPath       string `yaml:"rules_path" json:"rules_path"`
        CustomValidator string `yaml:"custom_validator" json:"custom_validator"`
}

// SchemaValidation contains schema validation settings
type SchemaValidation struct {
        Enabled      bool   `yaml:"enabled" json:"enabled"`
        SchemaPath   string `yaml:"schema_path" json:"schema_path"`
        StrictSchema bool   `yaml:"strict_schema" json:"strict_schema"`
}

// LoggingConfig contains logging configuration
type LoggingConfig struct {
        Level      string `yaml:"level" json:"level"`
        Output     string `yaml:"output" json:"output"`
        FilePath   string `yaml:"file_path" json:"file_path"`
        MaxSize    int    `yaml:"max_size" json:"max_size"`
        MaxBackups int    `yaml:"max_backups" json:"max_backups"`
        Compress   bool   `yaml:"compress" json:"compress"`
}

// PerformanceConfig contains performance configuration
type PerformanceConfig struct {
        EnableMetrics  bool `yaml:"enable_metrics" json:"enable_metrics"`
        SampleRate     int  `yaml:"sample_rate" json:"sample_rate"`
        BufferSize     int  `yaml:"buffer_size" json:"buffer_size"`
        TimeoutMs      int  `yaml:"timeout_ms" json:"timeout_ms"`
        MaxConcurrency int  `yaml:"max_concurrency" json:"max_concurrency"`
}

// SecurityConfig contains security configuration
type SecurityConfig struct {
        EnableCSRF     bool     `yaml:"enable_csrf" json:"enable_csrf"`
        TokenExpiry    int      `yaml:"token_expiry" json:"token_expiry"`
        AllowedOrigins []string `yaml:"allowed_origins" json:"allowed_origins"`
        RateLimit      int      `yaml:"rate_limit" json:"rate_limit"`
}

// Validate performs comprehensive validation on the Config
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Validate global configuration
        if err := c.Global.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erro na configuração global: %w", err)
        }</span>

        // Validate forms
        <span class="cov0" title="0">for i, form := range c.Forms </span><span class="cov0" title="0">{
                if err := form.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro no formulário %d: %w", i, err)
                }</span>
        }

        // Validate layouts
        <span class="cov0" title="0">for i, layout := range c.Layouts </span><span class="cov0" title="0">{
                if err := layout.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro no layout %d: %w", i, err)
                }</span>
        }

        // Validate tabs
        <span class="cov0" title="0">for i, tabs := range c.Tabs </span><span class="cov0" title="0">{
                if err := tabs.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro nas abas %d: %w", i, err)
                }</span>
        }

        // Validate themes
        <span class="cov0" title="0">for name, theme := range c.Themes </span><span class="cov0" title="0">{
                if err := theme.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro no tema %s: %w", name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate performs validation on GlobalConfig
func (gc *GlobalConfig) Validate() error <span class="cov0" title="0">{
        if gc.AppName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("nome da aplicação é obrigatório")
        }</span>
        <span class="cov0" title="0">if gc.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("versão é obrigatória")
        }</span>
        <span class="cov0" title="0">if gc.Environment == "" </span><span class="cov0" title="0">{
                gc.Environment = "development" // Default
        }</span>
        <span class="cov0" title="0">if gc.LogLevel == "" </span><span class="cov0" title="0">{
                gc.LogLevel = "info" // Default
        }</span>
        <span class="cov0" title="0">if gc.DefaultTheme == "" </span><span class="cov0" title="0">{
                gc.DefaultTheme = "default" // Default
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Validate performs validation on ThemeConfig
func (tc *ThemeConfig) Validate() error <span class="cov0" title="0">{
        if tc.BaseTheme == "" </span><span class="cov0" title="0">{
                tc.BaseTheme = "default"
        }</span>
        // Additional theme validation can be added here
        <span class="cov0" title="0">return nil</span>
}

// DefaultConfig returns a default configuration for the application
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Global: GlobalConfig{
                        AppName:      "Shantilly",
                        Version:      "1.0.0",
                        Environment:  "development",
                        Debug:        false,
                        LogLevel:     "info",
                        DefaultTheme: "default",
                        DefaultView:  "form",
                        Metadata: map[string]string{
                                "description": "Terminal UI framework for interactive forms",
                                "author":      "Shantilly Team",
                        },
                },
                Validation: ValidationConfig{
                        Component: ComponentValidation{
                                StrictMode: false,
                                RealTime:   true,
                                DebounceMs: 300,
                        },
                        CrossField: CrossFieldValidation{
                                Enabled:          true,
                                ValidateOnSubmit: true,
                        },
                        Business: BusinessValidation{
                                Enabled:   false,
                                RulesPath: "",
                        },
                        Schema: SchemaValidation{
                                Enabled:      false,
                                SchemaPath:   "",
                                StrictSchema: false,
                        },
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Output:     "stdout",
                        FilePath:   "",
                        MaxSize:    100,
                        MaxBackups: 3,
                        Compress:   true,
                },
                Performance: PerformanceConfig{
                        EnableMetrics:  false,
                        SampleRate:     1000,
                        BufferSize:     1000,
                        TimeoutMs:      5000,
                        MaxConcurrency: 10,
                },
                Security: SecurityConfig{
                        EnableCSRF:     false,
                        TokenExpiry:    3600,
                        AllowedOrigins: []string{"*"},
                        RateLimit:      100,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "reflect"
        "strings"

        "github.com/helton/shantilly/internal/errors"
        "gopkg.in/yaml.v3"
)

// ConfigManager manages application configuration with advanced features
type ConfigManager struct {
        configs        map[string]*Config
        activeConfig   string
        configPaths    []string
        watchers       []ConfigWatcher
        autoReload     bool
        validateOnLoad bool
}

// ConfigWatcher defines the interface for configuration change listeners
type ConfigWatcher interface {
        OnConfigChanged(configName string, newConfig *Config)
        OnConfigError(configName string, err error)
}

// ValidationRule defines a validation rule for configuration
type ValidationRule struct {
        Field    string
        Rule     string
        Value    interface{}
        Message  string
        Severity errors.ErrorSeverity
}

// ConfigLoadOptions defines options for loading configuration
type ConfigLoadOptions struct {
        Validate      bool
        Watch         bool
        Environment   string
        ConfigPaths   []string
        DefaultConfig *Config
}

// NewConfigManager creates a new configuration manager
func NewConfigManager() *ConfigManager <span class="cov0" title="0">{
        return &amp;ConfigManager{
                configs:        make(map[string]*Config),
                configPaths:    getDefaultConfigPaths(),
                autoReload:     false,
                validateOnLoad: true,
        }
}</span>

// LoadConfig loads configuration from a file with enhanced error handling and logging
func (cm *ConfigManager) LoadConfig(configPath string, options *ConfigLoadOptions) (*Config, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;ConfigLoadOptions{
                        Validate: true,
                        Watch:    false,
                }
        }</span>

        <span class="cov0" title="0">log.Printf("Loading configuration from: %s", configPath)

        // Read configuration file with enhanced error context
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                fileErr := errors.NewFileError(fmt.Sprintf("failed to read config file: %s", configPath), configPath)
                log.Printf("Config file read error: %v", fileErr)
                return nil, fileErr
        }</span>

        // Parse YAML with enhanced error handling
        <span class="cov0" title="0">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                parseErr := errors.NewConfigError(fmt.Sprintf("failed to parse YAML: %v", err))
                log.Printf("Config YAML parse error: %v", parseErr)
                return nil, parseErr
        }</span>

        // Apply environment-specific overrides
        <span class="cov0" title="0">if options.Environment != "" </span><span class="cov0" title="0">{
                log.Printf("Applying environment overrides for: %s", options.Environment)
                cm.applyEnvironmentOverrides(&amp;config, options.Environment)
        }</span>

        // Validate configuration with enhanced error reporting
        <span class="cov0" title="0">if options.Validate </span><span class="cov0" title="0">{
                if err := cm.validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Config validation error: %v", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Printf("Configuration validation successful")</span>
        }

        // Store configuration
        <span class="cov0" title="0">configName := cm.getConfigName(configPath)
        cm.configs[configName] = &amp;config
        log.Printf("Configuration stored as: %s", configName)

        // Set as active if it's the first config
        if cm.activeConfig == "" </span><span class="cov0" title="0">{
                cm.activeConfig = configName
                log.Printf("Set as active configuration: %s", configName)
        }</span>

        // Notify watchers
        <span class="cov0" title="0">cm.notifyWatchers(configName, &amp;config)

        log.Printf("Configuration loaded successfully from: %s", configPath)
        return &amp;config, nil</span>
}

// LoadConfigFromString loads configuration from a YAML string
func (cm *ConfigManager) LoadConfigFromString(yamlContent string, configName string) (*Config, error) <span class="cov0" title="0">{
        var config Config
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewConfigError(fmt.Sprintf("failed to parse YAML string: %v", err))
        }</span>

        <span class="cov0" title="0">if cm.validateOnLoad </span><span class="cov0" title="0">{
                if err := cm.validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">cm.configs[configName] = &amp;config

        // Set as active if it's the first config
        if cm.activeConfig == "" </span><span class="cov0" title="0">{
                cm.activeConfig = configName
        }</span>

        <span class="cov0" title="0">cm.notifyWatchers(configName, &amp;config)

        return &amp;config, nil</span>
}

// GetConfig returns the configuration by name
func (cm *ConfigManager) GetConfig(configName string) (*Config, error) <span class="cov0" title="0">{
        if config, exists := cm.configs[configName]; exists </span><span class="cov0" title="0">{
                return config, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.NewConfigError(fmt.Sprintf("configuration not found: %s", configName))</span>
}

// GetActiveConfig returns the currently active configuration
func (cm *ConfigManager) GetActiveConfig() (*Config, error) <span class="cov0" title="0">{
        if cm.activeConfig == "" </span><span class="cov0" title="0">{
                return nil, errors.NewConfigError("no active configuration set")
        }</span>
        <span class="cov0" title="0">return cm.GetConfig(cm.activeConfig)</span>
}

// SetActiveConfig sets the active configuration
func (cm *ConfigManager) SetActiveConfig(configName string) error <span class="cov0" title="0">{
        if _, exists := cm.configs[configName]; !exists </span><span class="cov0" title="0">{
                return errors.NewConfigError(fmt.Sprintf("configuration not found: %s", configName))
        }</span>
        <span class="cov0" title="0">cm.activeConfig = configName
        return nil</span>
}

// AddConfigPath adds a path to search for configuration files
func (cm *ConfigManager) AddConfigPath(path string) <span class="cov0" title="0">{
        cm.configPaths = append(cm.configPaths, path)
}</span>

// AddWatcher adds a configuration watcher
func (cm *ConfigManager) AddWatcher(watcher ConfigWatcher) <span class="cov0" title="0">{
        cm.watchers = append(cm.watchers, watcher)
}</span>

// SetAutoReload enables or disables automatic configuration reloading
func (cm *ConfigManager) SetAutoReload(enabled bool) <span class="cov0" title="0">{
        cm.autoReload = enabled
}</span>

// validateConfig performs comprehensive configuration validation
func (cm *ConfigManager) validateConfig(config *Config) error <span class="cov0" title="0">{
        // Basic validation
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Custom validation rules
        <span class="cov0" title="0">rules := cm.getValidationRules()
        for _, rule := range rules </span><span class="cov0" title="0">{
                if err := cm.applyValidationRule(config, rule); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getValidationRules returns comprehensive validation rules for configuration
func (cm *ConfigManager) getValidationRules() []ValidationRule <span class="cov0" title="0">{
        return []ValidationRule{
                // Global configuration rules
                {
                        Field:    "Global.AppName",
                        Rule:     "required",
                        Value:    nil,
                        Message:  "Application name is required",
                        Severity: errors.SeverityError,
                },
                {
                        Field:    "Global.Version",
                        Rule:     "required",
                        Value:    nil,
                        Message:  "Version is required",
                        Severity: errors.SeverityError,
                },
                {
                        Field:    "Global.LogLevel",
                        Rule:     "one_of",
                        Value:    []string{"debug", "info", "warn", "error"},
                        Message:  "Log level must be one of: debug, info, warn, error",
                        Severity: errors.SeverityWarning,
                },

                // Component validation rules
                {
                        Field:    "Validation.Component.StrictMode",
                        Rule:     "type",
                        Value:    "bool",
                        Message:  "Component strict mode must be a boolean",
                        Severity: errors.SeverityWarning,
                },

                // Performance configuration rules
                {
                        Field:    "Performance.EnableMetrics",
                        Rule:     "type",
                        Value:    "bool",
                        Message:  "Performance metrics enable flag must be a boolean",
                        Severity: errors.SeverityWarning,
                },

                // Security configuration rules
                {
                        Field:    "Security.EnableCSRF",
                        Rule:     "type",
                        Value:    "bool",
                        Message:  "CSRF protection flag must be a boolean",
                        Severity: errors.SeverityWarning,
                },

                // Logging configuration rules
                {
                        Field:    "Logging.Level",
                        Rule:     "one_of",
                        Value:    []string{"debug", "info", "warn", "error"},
                        Message:  "Logging level must be one of: debug, info, warn, error",
                        Severity: errors.SeverityWarning,
                },

                // Form validation rules
                {
                        Field:    "Forms",
                        Rule:     "min_length",
                        Value:    1,
                        Message:  "At least one form configuration is required",
                        Severity: errors.SeverityError,
                },
        }
}</span>

// applyValidationRule applies a validation rule to the configuration
func (cm *ConfigManager) applyValidationRule(config *Config, rule ValidationRule) error <span class="cov0" title="0">{
        value := cm.getFieldValue(config, rule.Field)
        if value == nil &amp;&amp; rule.Rule == "required" </span><span class="cov0" title="0">{
                return errors.NewValidationError(rule.Message, rule.Field)
        }</span>

        <span class="cov0" title="0">switch rule.Rule </span>{
        case "required":<span class="cov0" title="0">
                if value == nil || cm.isEmpty(value) </span><span class="cov0" title="0">{
                        return errors.NewValidationError(rule.Message, rule.Field)
                }</span>

        case "one_of":<span class="cov0" title="0">
                if allowedValues, ok := rule.Value.([]string); ok </span><span class="cov0" title="0">{
                        if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                found := false
                                for _, allowed := range allowedValues </span><span class="cov0" title="0">{
                                        if strValue == allowed </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        return errors.NewValidationError(rule.Message, rule.Field)
                                }</span>
                        }
                }

        case "type":<span class="cov0" title="0">
                expectedType := rule.Value.(string)
                actualType := reflect.TypeOf(value).String()
                if actualType != expectedType </span><span class="cov0" title="0">{
                        return errors.NewValidationError(
                                fmt.Sprintf("%s: expected %s, got %s", rule.Message, expectedType, actualType),
                                rule.Field,
                        )
                }</span>

        case "min_length":<span class="cov0" title="0">
                if minLen, ok := rule.Value.(int); ok </span><span class="cov0" title="0">{
                        if reflect.ValueOf(value).Len() &lt; minLen </span><span class="cov0" title="0">{
                                return errors.NewValidationError(rule.Message, rule.Field)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// getFieldValue retrieves a field value using reflection
func (cm *ConfigManager) getFieldValue(config *Config, fieldPath string) interface{} <span class="cov0" title="0">{
        parts := strings.Split(fieldPath, ".")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">v := reflect.ValueOf(config)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov0" title="0">for _, part := range parts </span><span class="cov0" title="0">{
                if v.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        v = v.FieldByName(cm.capitalizeFirst(part))
                }</span> else<span class="cov0" title="0"> if v.Kind() == reflect.Map </span><span class="cov0" title="0">{
                        // Handle map access for nested structures
                        return nil // Simplified for now
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>

                <span class="cov0" title="0">if !v.IsValid() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        v = v.Elem()
                }</span>
        }

        <span class="cov0" title="0">return v.Interface()</span>
}

// capitalizeFirst capitalizes the first letter of a string
func (cm *ConfigManager) capitalizeFirst(s string) string <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return strings.ToUpper(s[:1]) + s[1:]</span>
}

// isEmpty checks if a value is empty
func (cm *ConfigManager) isEmpty(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.TrimSpace(v) == ""</span>
        case int, int32, int64:<span class="cov0" title="0">
                return v == 0</span>
        case float32, float64:<span class="cov0" title="0">
                return v == 0.0</span>
        default:<span class="cov0" title="0">
                return reflect.ValueOf(value).IsZero()</span>
        }
}

// applyEnvironmentOverrides applies environment-specific configuration overrides
func (cm *ConfigManager) applyEnvironmentOverrides(config *Config, environment string) <span class="cov0" title="0">{
        // Apply environment-specific settings
        switch environment </span>{
        case "development":<span class="cov0" title="0">
                config.Global.Debug = true
                config.Global.LogLevel = "debug"
                config.Logging.Level = "debug"</span>

        case "production":<span class="cov0" title="0">
                config.Global.Debug = false
                config.Global.LogLevel = "info"
                config.Logging.Level = "info"
                config.Performance.EnableMetrics = true</span>

        case "testing":<span class="cov0" title="0">
                config.Global.Debug = true
                config.Global.LogLevel = "debug"
                config.Logging.Level = "debug"
                config.Validation.Component.StrictMode = false</span>
        }
}

// notifyWatchers notifies all watchers of configuration changes
func (cm *ConfigManager) notifyWatchers(configName string, config *Config) <span class="cov0" title="0">{
        for _, watcher := range cm.watchers </span><span class="cov0" title="0">{
                watcher.OnConfigChanged(configName, config)
        }</span>
}

// getConfigName extracts the configuration name from the file path
func (cm *ConfigManager) getConfigName(configPath string) string <span class="cov0" title="0">{
        base := filepath.Base(configPath)
        name := strings.TrimSuffix(base, filepath.Ext(base))
        return name
}</span>

// getDefaultConfigPaths returns the default configuration search paths
func getDefaultConfigPaths() []string <span class="cov0" title="0">{
        return []string{
                "./config.yaml",
                "./config.yml",
                "./configs/app.yaml",
                "./configs/app.yml",
                "./internal/config/app.yaml",
                "./internal/config/app.yml",
                "/etc/shantilly/config.yaml",
                "/etc/shantilly/config.yml",
        }
}</span>

// LoadDefaultConfig loads the default configuration
func (cm *ConfigManager) LoadDefaultConfig() (*Config, error) <span class="cov0" title="0">{
        // Try to load from default paths
        for _, path := range cm.configPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return cm.LoadConfig(path, &amp;ConfigLoadOptions{
                                Validate: true,
                                Watch:    cm.autoReload,
                        })
                }</span>
        }

        // If no config file found, use default configuration
        <span class="cov0" title="0">defaultConfig := DefaultConfig()
        cm.configs["default"] = defaultConfig
        cm.activeConfig = "default"

        cm.notifyWatchers("default", defaultConfig)

        return defaultConfig, nil</span>
}

// MergeConfigs merges multiple configurations with precedence
func (cm *ConfigManager) MergeConfigs(baseConfig *Config, overlayConfigs ...*Config) *Config <span class="cov0" title="0">{
        merged := *baseConfig // Copy the base config

        for _, overlay := range overlayConfigs </span><span class="cov0" title="0">{
                cm.mergeConfigStruct(&amp;merged, overlay)
        }</span>

        <span class="cov0" title="0">return &amp;merged</span>
}

// mergeConfigStruct merges two configuration structs recursively
func (cm *ConfigManager) mergeConfigStruct(base, overlay *Config) <span class="cov0" title="0">{
        baseVal := reflect.ValueOf(base).Elem()
        overlayVal := reflect.ValueOf(overlay).Elem()

        for i := 0; i &lt; baseVal.NumField(); i++ </span><span class="cov0" title="0">{
                baseField := baseVal.Field(i)
                overlayField := overlayVal.Field(i)

                if overlayField.IsValid() &amp;&amp; !cm.isEmpty(overlayField.Interface()) </span><span class="cov0" title="0">{
                        if baseField.CanSet() </span><span class="cov0" title="0">{
                                if baseField.Kind() == reflect.Struct &amp;&amp; overlayField.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                        // Recursively merge nested structs
                                        cm.mergeStructFields(baseField, overlayField)
                                }</span> else<span class="cov0" title="0"> {
                                        baseField.Set(overlayField)
                                }</span>
                        }
                }
        }
}

// mergeStructFields merges fields of two structs
func (cm *ConfigManager) mergeStructFields(base, overlay reflect.Value) <span class="cov0" title="0">{
        for i := 0; i &lt; base.NumField(); i++ </span><span class="cov0" title="0">{
                baseField := base.Field(i)
                overlayField := overlay.Field(i)

                if overlayField.IsValid() &amp;&amp; !cm.isEmpty(overlayField.Interface()) </span><span class="cov0" title="0">{
                        if baseField.CanSet() </span><span class="cov0" title="0">{
                                if baseField.Kind() == reflect.String &amp;&amp; overlayField.Kind() == reflect.String </span><span class="cov0" title="0">{
                                        if overlayField.String() != "" </span><span class="cov0" title="0">{
                                                baseField.SetString(overlayField.String())
                                        }</span>
                                } else<span class="cov0" title="0"> if baseField.Kind() == reflect.Bool &amp;&amp; overlayField.Kind() == reflect.Bool </span><span class="cov0" title="0">{
                                        baseField.SetBool(overlayField.Bool())
                                }</span> else<span class="cov0" title="0"> if baseField.Kind() == reflect.Int &amp;&amp; overlayField.Kind() == reflect.Int </span><span class="cov0" title="0">{
                                        baseField.SetInt(overlayField.Int())
                                }</span>
                        }
                }
        }
}

// ExportConfig exports the current configuration to a file
func (cm *ConfigManager) ExportConfig(configName, filePath string) error <span class="cov0" title="0">{
        config, exists := cm.configs[configName]
        if !exists </span><span class="cov0" title="0">{
                return errors.NewConfigError(fmt.Sprintf("configuration not found: %s", configName))
        }</span>

        <span class="cov0" title="0">data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewConfigError(fmt.Sprintf("failed to marshal config: %v", err))
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return errors.NewFileError(fmt.Sprintf("failed to write config file: %s", filePath), filePath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateAllConfigs validates all loaded configurations
func (cm *ConfigManager) ValidateAllConfigs() error <span class="cov0" title="0">{
        var validationErrors []error

        for name, config := range cm.configs </span><span class="cov0" title="0">{
                if err := cm.validateConfig(config); err != nil </span><span class="cov0" title="0">{
                        validationErrors = append(validationErrors,
                                fmt.Errorf("validation failed for config %s: %w", name, err))
                }</span>
        }

        <span class="cov0" title="0">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("multiple validation errors: %v", validationErrors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigSummary returns a summary of all loaded configurations
func (cm *ConfigManager) GetConfigSummary() map[string]interface{} <span class="cov0" title="0">{
        summary := map[string]interface{}{
                "active_config":    cm.activeConfig,
                "loaded_configs":   len(cm.configs),
                "config_names":     cm.getConfigNames(),
                "auto_reload":      cm.autoReload,
                "validate_on_load": cm.validateOnLoad,
                "config_paths":     cm.configPaths,
                "watchers_count":   len(cm.watchers),
        }

        return summary
}</span>

// getConfigNames returns the names of all loaded configurations
func (cm *ConfigManager) getConfigNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(cm.configs))
        for name := range cm.configs </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// CreateEnvironmentConfig creates a configuration optimized for a specific environment
func (cm *ConfigManager) CreateEnvironmentConfig(baseConfig *Config, environment string) *Config <span class="cov0" title="0">{
        config := *baseConfig // Copy the base config

        // Apply environment-specific optimizations
        switch environment </span>{
        case "development":<span class="cov0" title="0">
                config.Global.Environment = "development"
                config.Global.Debug = true
                config.Global.LogLevel = "debug"
                config.Logging.Level = "debug"
                config.Validation.Component.StrictMode = false
                config.Performance.EnableMetrics = false</span>

        case "testing":<span class="cov0" title="0">
                config.Global.Environment = "testing"
                config.Global.Debug = true
                config.Global.LogLevel = "debug"
                config.Logging.Level = "debug"
                config.Validation.Component.StrictMode = false
                config.Performance.EnableMetrics = false</span>

        case "staging":<span class="cov0" title="0">
                config.Global.Environment = "staging"
                config.Global.Debug = false
                config.Global.LogLevel = "info"
                config.Logging.Level = "info"
                config.Validation.Component.StrictMode = true
                config.Performance.EnableMetrics = true</span>

        case "production":<span class="cov0" title="0">
                config.Global.Environment = "production"
                config.Global.Debug = false
                config.Global.LogLevel = "warn"
                config.Logging.Level = "warn"
                config.Validation.Component.StrictMode = true
                config.Performance.EnableMetrics = true
                config.Security.EnableCSRF = true</span>
        }

        <span class="cov0" title="0">return &amp;config</span>
}

// LoadConfigWithDefaults loads configuration with default fallbacks
func (cm *ConfigManager) LoadConfigWithDefaults(configPath string, defaults *Config) (*Config, error) <span class="cov0" title="0">{
        options := &amp;ConfigLoadOptions{
                Validate:      true,
                DefaultConfig: defaults,
        }

        // Try to load the specified config
        if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                if config, err := cm.LoadConfig(configPath, options); err == nil </span><span class="cov0" title="0">{
                        return config, nil
                }</span>
        }

        // Fall back to defaults if specified config doesn't exist or fails to load
        <span class="cov0" title="0">if defaults != nil </span><span class="cov0" title="0">{
                cm.configs["default"] = defaults
                cm.activeConfig = "default"
                cm.notifyWatchers("default", defaults)
                return defaults, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.NewConfigError(fmt.Sprintf("failed to load config from %s and no defaults provided", configPath))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// ComponentType defines the type of UI component.
type ComponentType string

const (
        TypeTextInput  ComponentType = "textinput"
        TypeTextArea   ComponentType = "textarea"
        TypeCheckbox   ComponentType = "checkbox"
        TypeRadioGroup ComponentType = "radiogroup"
        TypeSlider     ComponentType = "slider"
        TypeFilePicker ComponentType = "filepicker"
        TypeText       ComponentType = "text" // Static label
)

// ComponentConfig represents the declarative configuration for a single component.
// This structure is parsed from YAML and used to initialize components.
type ComponentConfig struct {
        Type        ComponentType          `yaml:"type"`
        Name        string                 `yaml:"name"`
        Label       string                 `yaml:"label,omitempty"`
        Placeholder string                 `yaml:"placeholder,omitempty"`
        Default     interface{}            `yaml:"default,omitempty"`
        Required    bool                   `yaml:"required,omitempty"`
        Help        string                 `yaml:"help,omitempty"`
        Options     map[string]interface{} `yaml:"options,omitempty"`
}

// Validate performs validation on the ComponentConfig.
// Returns an error if the configuration is invalid.
func (c *ComponentConfig) Validate() error <span class="cov8" title="10">{
        if c.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("nome do componente é obrigatório")
        }</span>

        <span class="cov8" title="9">validTypes := []ComponentType{
                TypeTextInput, TypeTextArea, TypeCheckbox,
                TypeRadioGroup, TypeSlider, TypeFilePicker, TypeText,
        }

        valid := false
        for _, t := range validTypes </span><span class="cov10" title="15">{
                if c.Type == t </span><span class="cov7" title="8">{
                        valid = true
                        break</span>
                }
        }

        <span class="cov8" title="9">if !valid </span><span class="cov1" title="1">{
                return fmt.Errorf("tipo de componente inválido: %s", c.Type)
        }</span>

        <span class="cov7" title="8">return nil</span>
}

// FormConfig represents the complete form configuration with multiple components.
type FormConfig struct {
        Title       string            `yaml:"title,omitempty"`
        Description string            `yaml:"description,omitempty"`
        Components  []ComponentConfig `yaml:"components"`
}

// Validate performs validation on the FormConfig.
func (f *FormConfig) Validate() error <span class="cov5" title="4">{
        if len(f.Components) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("a configuração deve conter pelo menos um componente")
        }</span>

        // Validate each component
        <span class="cov4" title="3">for i, comp := range f.Components </span><span class="cov5" title="4">{
                if err := comp.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro no componente %d: %w", i, err)
                }</span>
        }

        // Check for duplicate component names
        <span class="cov4" title="3">names := make(map[string]bool)
        for _, comp := range f.Components </span><span class="cov5" title="4">{
                if names[comp.Name] </span><span class="cov1" title="1">{
                        return fmt.Errorf("nome de componente duplicado: %s", comp.Name)
                }</span>
                <span class="cov4" title="3">names[comp.Name] = true</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// LayoutConfig represents a layout configuration with positioned components.
type LayoutConfig struct {
        Title       string            `yaml:"title,omitempty"`
        Description string            `yaml:"description,omitempty"`
        Layout      string            `yaml:"layout"` // "horizontal" or "vertical"
        Components  []ComponentConfig `yaml:"components"`
}

// Validate performs validation on the LayoutConfig.
func (l *LayoutConfig) Validate() error <span class="cov5" title="4">{
        if l.Layout != "horizontal" &amp;&amp; l.Layout != "vertical" </span><span class="cov1" title="1">{
                return fmt.Errorf("layout deve ser 'horizontal' ou 'vertical', recebido: %s", l.Layout)
        }</span>

        <span class="cov4" title="3">if len(l.Components) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("a configuração deve conter pelo menos um componente")
        }</span>

        <span class="cov3" title="2">for i, comp := range l.Components </span><span class="cov3" title="2">{
                if err := comp.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erro no componente %d: %w", i, err)
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// MenuConfig represents a menu/list selection configuration.
type MenuConfig struct {
        Title       string   `yaml:"title,omitempty"`
        Description string   `yaml:"description,omitempty"`
        Items       []string `yaml:"items"`
        MultiSelect bool     `yaml:"multi_select,omitempty"`
}

// Validate performs validation on the MenuConfig.
func (m *MenuConfig) Validate() error <span class="cov3" title="2">{
        if len(m.Items) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("o menu deve conter pelo menos um item")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// TabConfig represents a single tab configuration.
type TabConfig struct {
        Name       string            `yaml:"name"`
        Label      string            `yaml:"label"`
        Components []ComponentConfig `yaml:"components"`
}

// TabsConfig represents a tabs configuration with multiple tabs.
type TabsConfig struct {
        Title string      `yaml:"title,omitempty"`
        Tabs  []TabConfig `yaml:"tabs"`
}

// Validate performs validation on the TabsConfig.
func (t *TabsConfig) Validate() error <span class="cov4" title="3">{
        if len(t.Tabs) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("a configuração deve conter pelo menos uma aba")
        }</span>

        <span class="cov3" title="2">for i, tab := range t.Tabs </span><span class="cov3" title="2">{
                if tab.Name == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("aba %d: nome é obrigatório", i)
                }</span>
                <span class="cov1" title="1">if tab.Label == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("aba %d: label é obrigatório", i)
                }</span>

                <span class="cov1" title="1">for j, comp := range tab.Components </span><span class="cov1" title="1">{
                        if err := comp.Validate(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("aba %d, componente %d: %w", i, j, err)
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// LoadFormConfig loads and validates a FormConfig from a YAML file.
// Returns an error with context if loading or validation fails.
func LoadFormConfig(filePath string) (*FormConfig, error) <span class="cov4" title="3">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao ler o arquivo de configuração: %w", err)
        }</span>

        <span class="cov3" title="2">var config FormConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao analisar o YAML de configuração: %w", err)
        }</span>

        <span class="cov1" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro de validação da configuração: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;config, nil</span>
}

// LoadLayoutConfig loads and validates a LayoutConfig from a YAML file.
func LoadLayoutConfig(filePath string) (*LayoutConfig, error) <span class="cov3" title="2">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao ler o arquivo de configuração: %w", err)
        }</span>

        <span class="cov1" title="1">var config LayoutConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao analisar o YAML de configuração: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro de validação da configuração: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// LoadMenuConfig loads and validates a MenuConfig from a YAML file.
func LoadMenuConfig(filePath string) (*MenuConfig, error) <span class="cov3" title="2">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao ler o arquivo de configuração: %w", err)
        }</span>

        <span class="cov1" title="1">var config MenuConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao analisar o YAML de configuração: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro de validação da configuração: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// LoadTabsConfig loads and validates a TabsConfig from a YAML file.
func LoadTabsConfig(filePath string) (*TabsConfig, error) <span class="cov3" title="2">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao ler o arquivo de configuração: %w", err)
        }</span>

        <span class="cov1" title="1">var config TabsConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("erro ao analisar o YAML de configuração: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro de validação da configuração: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package errors

import (
        "fmt"
        "runtime"
        "strings"
        "time"
)

// ErrorSeverity defines the severity levels for errors
type ErrorSeverity int

const (
        SeverityInfo ErrorSeverity = iota
        SeverityWarning
        SeverityError
        SeverityCritical
        SeverityFatal
)

// String returns the string representation of ErrorSeverity
func (es ErrorSeverity) String() string <span class="cov0" title="0">{
        switch es </span>{
        case SeverityInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case SeverityWarning:<span class="cov0" title="0">
                return "WARNING"</span>
        case SeverityError:<span class="cov0" title="0">
                return "ERROR"</span>
        case SeverityCritical:<span class="cov0" title="0">
                return "CRITICAL"</span>
        case SeverityFatal:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ErrorCode defines standardized error codes for the application
type ErrorCode int

const (
        // Component errors (1000-1099)
        ErrComponentNotFound ErrorCode = iota + 1000
        ErrComponentCreationFailed
        ErrComponentValidationFailed
        ErrComponentDependencyFailed
        ErrComponentStateInvalid

        // Configuration errors (1100-1199)
        ErrConfigInvalid ErrorCode = iota + 1100
        ErrConfigLoadFailed
        ErrConfigValidationFailed
        ErrConfigNotFound

        // Theme errors (1200-1299)
        ErrThemeLoadFailed ErrorCode = iota + 1200
        ErrThemeValidationFailed
        ErrThemeNotFound

        // Model errors (1300-1399)
        ErrModelCreationFailed ErrorCode = iota + 1300
        ErrModelStateInvalid
        ErrModelNavigationFailed

        // File system errors (1400-1499)
        ErrFileOperationFailed ErrorCode = iota + 1400
        ErrFileNotFound
        ErrFilePermissionDenied
        ErrFileInvalidFormat

        // Network errors (1500-1599)
        ErrNetworkOperationFailed ErrorCode = iota + 1500
        ErrNetworkTimeout
        ErrNetworkConnectionFailed

        // Validation errors (1600-1699)
        ErrValidationFailed ErrorCode = iota + 1600
        ErrValidationCrossFieldFailed
        ErrValidationBusinessRuleFailed

        // Runtime errors (1700-1799)
        ErrMemoryAllocationFailed ErrorCode = iota + 1700
        ErrConcurrencyIssue
        ErrTimeout
        ErrResourceExhausted
)

// String returns the string representation of ErrorCode
func (ec ErrorCode) String() string <span class="cov0" title="0">{
        switch ec </span>{
        case ErrComponentNotFound:<span class="cov0" title="0">
                return "COMPONENT_NOT_FOUND"</span>
        case ErrComponentCreationFailed:<span class="cov0" title="0">
                return "COMPONENT_CREATION_FAILED"</span>
        case ErrComponentValidationFailed:<span class="cov0" title="0">
                return "COMPONENT_VALIDATION_FAILED"</span>
        case ErrComponentDependencyFailed:<span class="cov0" title="0">
                return "COMPONENT_DEPENDENCY_FAILED"</span>
        case ErrComponentStateInvalid:<span class="cov0" title="0">
                return "COMPONENT_STATE_INVALID"</span>
        case ErrConfigInvalid:<span class="cov0" title="0">
                return "CONFIG_INVALID"</span>
        case ErrConfigLoadFailed:<span class="cov0" title="0">
                return "CONFIG_LOAD_FAILED"</span>
        case ErrConfigValidationFailed:<span class="cov0" title="0">
                return "CONFIG_VALIDATION_FAILED"</span>
        case ErrConfigNotFound:<span class="cov0" title="0">
                return "CONFIG_NOT_FOUND"</span>
        case ErrThemeLoadFailed:<span class="cov0" title="0">
                return "THEME_LOAD_FAILED"</span>
        case ErrThemeValidationFailed:<span class="cov0" title="0">
                return "THEME_VALIDATION_FAILED"</span>
        case ErrThemeNotFound:<span class="cov0" title="0">
                return "THEME_NOT_FOUND"</span>
        case ErrModelCreationFailed:<span class="cov0" title="0">
                return "MODEL_CREATION_FAILED"</span>
        case ErrModelStateInvalid:<span class="cov0" title="0">
                return "MODEL_STATE_INVALID"</span>
        case ErrModelNavigationFailed:<span class="cov0" title="0">
                return "MODEL_NAVIGATION_FAILED"</span>
        case ErrFileOperationFailed:<span class="cov0" title="0">
                return "FILE_OPERATION_FAILED"</span>
        case ErrFileNotFound:<span class="cov0" title="0">
                return "FILE_NOT_FOUND"</span>
        case ErrFilePermissionDenied:<span class="cov0" title="0">
                return "FILE_PERMISSION_DENIED"</span>
        case ErrFileInvalidFormat:<span class="cov0" title="0">
                return "FILE_INVALID_FORMAT"</span>
        case ErrNetworkOperationFailed:<span class="cov0" title="0">
                return "NETWORK_OPERATION_FAILED"</span>
        case ErrNetworkTimeout:<span class="cov0" title="0">
                return "NETWORK_TIMEOUT"</span>
        case ErrNetworkConnectionFailed:<span class="cov0" title="0">
                return "NETWORK_CONNECTION_FAILED"</span>
        case ErrValidationFailed:<span class="cov0" title="0">
                return "VALIDATION_FAILED"</span>
        case ErrValidationCrossFieldFailed:<span class="cov0" title="0">
                return "VALIDATION_CROSS_FIELD_FAILED"</span>
        case ErrValidationBusinessRuleFailed:<span class="cov0" title="0">
                return "VALIDATION_BUSINESS_RULE_FAILED"</span>
        case ErrMemoryAllocationFailed:<span class="cov0" title="0">
                return "MEMORY_ALLOCATION_FAILED"</span>
        case ErrConcurrencyIssue:<span class="cov0" title="0">
                return "CONCURRENCY_ISSUE"</span>
        case ErrTimeout:<span class="cov0" title="0">
                return "TIMEOUT"</span>
        case ErrResourceExhausted:<span class="cov0" title="0">
                return "RESOURCE_EXHAUSTED"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("UNKNOWN_ERROR_%d", int(ec))</span>
        }
}

// AppError represents a structured application error with full context
type AppError struct {
        ID         string                 `json:"id"`
        Code       ErrorCode              `json:"code"`
        Message    string                 `json:"message"`
        Component  string                 `json:"component"`
        Severity   ErrorSeverity          `json:"severity"`
        Context    map[string]interface{} `json:"context"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Timestamp  time.Time              `json:"timestamp"`
        Resolved   bool                   `json:"resolved"`
        Retryable  bool                   `json:"retryable"`
}

// Error implements the error interface
func (e *AppError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s] %s: %s", e.Severity.String(), e.Code.String(), e.Message)
}</span>

// NewAppError creates a new AppError with the specified parameters
func NewAppError(code ErrorCode, message, component string, severity ErrorSeverity) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                ID:         generateErrorID(),
                Code:       code,
                Message:    message,
                Component:  component,
                Severity:   severity,
                Context:    make(map[string]interface{}),
                StackTrace: captureStackTrace(),
                Timestamp:  time.Now(),
                Resolved:   false,
                Retryable:  isRetryable(code),
        }
}</span>

// WithContext adds context information to the error
func (e *AppError) WithContext(key string, value interface{}) *AppError <span class="cov0" title="0">{
        if e.Context == nil </span><span class="cov0" title="0">{
                e.Context = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">e.Context[key] = value
        return e</span>
}

// WithContextMap adds multiple context values to the error
func (e *AppError) WithContextMap(context map[string]interface{}) *AppError <span class="cov0" title="0">{
        if e.Context == nil </span><span class="cov0" title="0">{
                e.Context = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">for key, value := range context </span><span class="cov0" title="0">{
                e.Context[key] = value
        }</span>
        <span class="cov0" title="0">return e</span>
}

// Resolve marks the error as resolved
func (e *AppError) Resolve() <span class="cov0" title="0">{
        e.Resolved = true
}</span>

// IsRetryable returns true if the error is retryable
func (e *AppError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Retryable
}</span>

// IsCritical returns true if the error is critical or fatal
func (e *AppError) IsCritical() bool <span class="cov0" title="0">{
        return e.Severity == SeverityCritical || e.Severity == SeverityFatal
}</span>

// ErrorManager manages application errors with advanced features
type ErrorManager struct {
        errors      []AppError
        maxErrors   int
        listeners   []ErrorListener
        autoResolve bool
        filterLevel ErrorSeverity
}

// ErrorListener defines the interface for error listeners
type ErrorListener interface {
        OnError(error *AppError)
        OnErrorResolved(errorID string)
}

// NewErrorManager creates a new ErrorManager
func NewErrorManager(maxErrors int) *ErrorManager <span class="cov0" title="0">{
        return &amp;ErrorManager{
                errors:      make([]AppError, 0),
                maxErrors:   maxErrors,
                listeners:   make([]ErrorListener, 0),
                autoResolve: false,
                filterLevel: SeverityInfo,
        }
}</span>

// AddError adds a new error to the manager
func (em *ErrorManager) AddError(err *AppError) <span class="cov0" title="0">{
        // Filter by severity level
        if err.Severity &lt; em.filterLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">em.errors = append(em.errors, *err)

        // Limit the number of stored errors
        if len(em.errors) &gt; em.maxErrors </span><span class="cov0" title="0">{
                em.errors = em.errors[len(em.errors)-em.maxErrors:]
        }</span>

        // Notify listeners
        <span class="cov0" title="0">for _, listener := range em.listeners </span><span class="cov0" title="0">{
                listener.OnError(err)
        }</span>
}

// ResolveError marks an error as resolved
func (em *ErrorManager) ResolveError(errorID string) <span class="cov0" title="0">{
        for i := range em.errors </span><span class="cov0" title="0">{
                if em.errors[i].ID == errorID </span><span class="cov0" title="0">{
                        em.errors[i].Resolved = true

                        // Notify listeners
                        for _, listener := range em.listeners </span><span class="cov0" title="0">{
                                listener.OnErrorResolved(errorID)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// GetErrors returns all errors, optionally filtered by severity
func (em *ErrorManager) GetErrors(minSeverity ErrorSeverity) []AppError <span class="cov0" title="0">{
        var filtered []AppError
        for _, err := range em.errors </span><span class="cov0" title="0">{
                if err.Severity &gt;= minSeverity </span><span class="cov0" title="0">{
                        filtered = append(filtered, err)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// GetUnresolvedErrors returns all unresolved errors
func (em *ErrorManager) GetUnresolvedErrors() []AppError <span class="cov0" title="0">{
        var unresolved []AppError
        for _, err := range em.errors </span><span class="cov0" title="0">{
                if !err.Resolved </span><span class="cov0" title="0">{
                        unresolved = append(unresolved, err)
                }</span>
        }
        <span class="cov0" title="0">return unresolved</span>
}

// ClearResolved removes all resolved errors
func (em *ErrorManager) ClearResolved() <span class="cov0" title="0">{
        var active []AppError
        for _, err := range em.errors </span><span class="cov0" title="0">{
                if !err.Resolved </span><span class="cov0" title="0">{
                        active = append(active, err)
                }</span>
        }
        <span class="cov0" title="0">em.errors = active</span>
}

// AddListener adds an error listener
func (em *ErrorManager) AddListener(listener ErrorListener) <span class="cov0" title="0">{
        em.listeners = append(em.listeners, listener)
}</span>

// SetFilterLevel sets the minimum severity level for error filtering
func (em *ErrorManager) SetFilterLevel(level ErrorSeverity) <span class="cov0" title="0">{
        em.filterLevel = level
}</span>

// Helper functions

func generateErrorID() string <span class="cov0" title="0">{
        return fmt.Sprintf("err_%d", time.Now().UnixNano())
}</span>

func captureStackTrace() string <span class="cov0" title="0">{
        // Skip this function and the caller
        const depth = 32
        var pcs [depth]uintptr
        n := runtime.Callers(2, pcs[:])

        frames := runtime.CallersFrames(pcs[:n])
        var stack strings.Builder

        for </span><span class="cov0" title="0">{
                frame, more := frames.Next()
                stack.WriteString(fmt.Sprintf("%s:%d %s\n", frame.File, frame.Line, frame.Function))

                if !more </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return stack.String()</span>
}

func isRetryable(code ErrorCode) bool <span class="cov0" title="0">{
        switch code </span>{
        case ErrNetworkTimeout, ErrNetworkConnectionFailed, ErrFilePermissionDenied:<span class="cov0" title="0">
                return true</span>
        case ErrComponentValidationFailed, ErrValidationFailed:<span class="cov0" title="0">
                return false</span>
        case ErrMemoryAllocationFailed, ErrResourceExhausted:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return true</span> // Most errors are retryable by default
        }
}

// Common error creation functions

// NewComponentError creates a component-related error
func NewComponentError(message, component string, severity ErrorSeverity) *AppError <span class="cov0" title="0">{
        code := ErrComponentCreationFailed
        if severity == SeverityError </span><span class="cov0" title="0">{
                code = ErrComponentValidationFailed
        }</span>
        <span class="cov0" title="0">return NewAppError(code, message, component, severity)</span>
}

// NewValidationError creates a validation-related error
func NewValidationError(message, field string) *AppError <span class="cov0" title="0">{
        return NewAppError(ErrValidationFailed, message, field, SeverityWarning)
}</span>

// NewConfigError creates a configuration-related error
func NewConfigError(message string) *AppError <span class="cov0" title="0">{
        return NewAppError(ErrConfigInvalid, message, "config", SeverityError)
}</span>

// NewFileError creates a file operation error
func NewFileError(message, filePath string) *AppError <span class="cov0" title="0">{
        return NewAppError(ErrFileOperationFailed, message, filePath, SeverityError)
}</span>

// NewNetworkError creates a network-related error
func NewNetworkError(message string) *AppError <span class="cov0" title="0">{
        return NewAppError(ErrNetworkOperationFailed, message, "network", SeverityWarning)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package errors

import (
        "fmt"
        "log"
        "time"
)

// ErrorHandler defines the interface for error handling strategies
type ErrorHandler interface {
        Handle(err *AppError) error
        CanHandle(err *AppError) bool
        GetPriority() int
}

// RecoveryStrategy defines how to recover from errors
type RecoveryStrategy int

const (
        RecoveryRetry RecoveryStrategy = iota
        RecoveryFallback
        RecoverySkip
        RecoveryFail
)

// ErrorMiddleware provides error handling middleware functionality
type ErrorMiddleware struct {
        handlers       []ErrorHandler
        errorManager   *ErrorManager
        enableLogging  bool
        enableRecovery bool
        retryConfig    RetryConfig
}

// RetryConfig defines retry behavior for recoverable errors
type RetryConfig struct {
        MaxRetries      int
        BaseDelay       time.Duration
        MaxDelay        time.Duration
        Multiplier      float64
        RetryableErrors []ErrorCode
}

// DefaultRetryConfig returns a sensible default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxRetries: 3,
                BaseDelay:  time.Second,
                MaxDelay:   time.Minute,
                Multiplier: 2.0,
                RetryableErrors: []ErrorCode{
                        ErrNetworkTimeout,
                        ErrNetworkConnectionFailed,
                        ErrFilePermissionDenied,
                        ErrTimeout,
                },
        }
}</span>

// NewErrorMiddleware creates a new ErrorMiddleware instance
func NewErrorMiddleware(manager *ErrorManager) *ErrorMiddleware <span class="cov0" title="0">{
        return &amp;ErrorMiddleware{
                handlers:       make([]ErrorHandler, 0),
                errorManager:   manager,
                enableLogging:  true,
                enableRecovery: true,
                retryConfig:    DefaultRetryConfig(),
        }
}</span>

// AddHandler adds an error handler to the middleware
func (em *ErrorMiddleware) AddHandler(handler ErrorHandler) <span class="cov0" title="0">{
        em.handlers = append(em.handlers, handler)

        // Sort handlers by priority (higher priority first)
        for i := len(em.handlers) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                if em.handlers[i].GetPriority() &gt; em.handlers[i-1].GetPriority() </span><span class="cov0" title="0">{
                        em.handlers[i], em.handlers[i-1] = em.handlers[i-1], em.handlers[i]
                }</span>
        }
}

// ProcessError processes an error through the middleware pipeline
func (em *ErrorMiddleware) ProcessError(err *AppError) error <span class="cov0" title="0">{
        // Add to error manager
        em.errorManager.AddError(err)

        // Log if enabled
        if em.enableLogging </span><span class="cov0" title="0">{
                em.logError(err)
        }</span>

        // Try recovery if enabled
        <span class="cov0" title="0">if em.enableRecovery </span><span class="cov0" title="0">{
                if recovered := em.tryRecovery(err); recovered </span><span class="cov0" title="0">{
                        err.Resolve()
                        em.errorManager.ResolveError(err.ID)
                        return nil
                }</span>
        }

        // Try handlers
        <span class="cov0" title="0">for _, handler := range em.handlers </span><span class="cov0" title="0">{
                if handler.CanHandle(err) </span><span class="cov0" title="0">{
                        if recoveryErr := handler.Handle(err); recoveryErr == nil </span><span class="cov0" title="0">{
                                err.Resolve()
                                em.errorManager.ResolveError(err.ID)
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}

// tryRecovery attempts to recover from the error automatically
func (em *ErrorMiddleware) tryRecovery(err *AppError) bool <span class="cov0" title="0">{
        // Check if error is retryable
        if !err.IsRetryable() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if error code is in retryable list
        <span class="cov0" title="0">for _, retryableCode := range em.retryConfig.RetryableErrors </span><span class="cov0" title="0">{
                if err.Code == retryableCode </span><span class="cov0" title="0">{
                        return em.executeRetryStrategy(err)
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// executeRetryStrategy executes the retry strategy for an error
func (em *ErrorMiddleware) executeRetryStrategy(err *AppError) bool <span class="cov0" title="0">{
        // This would implement exponential backoff retry logic
        // For now, we'll implement a simple retry mechanism

        delay := em.retryConfig.BaseDelay
        for i := 0; i &lt; em.retryConfig.MaxRetries; i++ </span><span class="cov0" title="0">{
                time.Sleep(delay)

                // In a real implementation, this would retry the operation
                // For now, we'll simulate a successful retry for network errors
                if err.Code == ErrNetworkTimeout || err.Code == ErrNetworkConnectionFailed </span><span class="cov0" title="0">{
                        // Simulate network recovery
                        if i == em.retryConfig.MaxRetries-1 </span><span class="cov0" title="0">{
                                return true // Success on last retry
                        }</span>
                }

                <span class="cov0" title="0">delay = time.Duration(float64(delay) * em.retryConfig.Multiplier)
                if delay &gt; em.retryConfig.MaxDelay </span><span class="cov0" title="0">{
                        delay = em.retryConfig.MaxDelay
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// logError logs an error with appropriate formatting
func (em *ErrorMiddleware) logError(err *AppError) <span class="cov0" title="0">{
        logLevel := getLogLevel(err.Severity)

        if err.IsCritical() </span><span class="cov0" title="0">{
                log.Printf("[%s] CRITICAL ERROR [%s] %s in %s: %s",
                        logLevel, err.ID, err.Code.String(), err.Component, err.Message)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[%s] ERROR [%s] %s: %s",
                        logLevel, err.ID, err.Code.String(), err.Message)
        }</span>

        // Log context if present
        <span class="cov0" title="0">if len(err.Context) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("  Context: %+v", err.Context)
        }</span>

        // Log stack trace for critical errors
        <span class="cov0" title="0">if err.IsCritical() &amp;&amp; err.StackTrace != "" </span><span class="cov0" title="0">{
                log.Printf("  Stack Trace:\n%s", err.StackTrace)
        }</span>
}

// getLogLevel converts error severity to log level
func getLogLevel(severity ErrorSeverity) string <span class="cov0" title="0">{
        switch severity </span>{
        case SeverityInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case SeverityWarning:<span class="cov0" title="0">
                return "WARN"</span>
        case SeverityError:<span class="cov0" title="0">
                return "ERROR"</span>
        case SeverityCritical:<span class="cov0" title="0">
                return "CRITICAL"</span>
        case SeverityFatal:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// RecoveryHandler implements automatic error recovery strategies
type RecoveryHandler struct {
        strategies map[ErrorCode]RecoveryStrategy
        priority   int
}

// NewRecoveryHandler creates a new recovery handler
func NewRecoveryHandler() *RecoveryHandler <span class="cov0" title="0">{
        return &amp;RecoveryHandler{
                strategies: map[ErrorCode]RecoveryStrategy{
                        ErrNetworkTimeout:          RecoveryRetry,
                        ErrNetworkConnectionFailed: RecoveryRetry,
                        ErrFilePermissionDenied:    RecoveryRetry,
                        ErrValidationFailed:        RecoverySkip,
                        ErrComponentNotFound:       RecoveryFallback,
                        ErrConfigInvalid:           RecoveryFail,
                },
                priority: 100,
        }
}</span>

// Handle implements ErrorHandler
func (rh *RecoveryHandler) Handle(err *AppError) error <span class="cov0" title="0">{
        strategy, exists := rh.strategies[err.Code]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no recovery strategy for error code: %s", err.Code.String())
        }</span>

        <span class="cov0" title="0">switch strategy </span>{
        case RecoveryRetry:<span class="cov0" title="0">
                return rh.handleRetry(err)</span>
        case RecoveryFallback:<span class="cov0" title="0">
                return rh.handleFallback(err)</span>
        case RecoverySkip:<span class="cov0" title="0">
                return nil</span> // Skip the operation
        case RecoveryFail:<span class="cov0" title="0">
                return err</span> // Fail fast
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown recovery strategy")</span>
        }
}

// CanHandle implements ErrorHandler
func (rh *RecoveryHandler) CanHandle(err *AppError) bool <span class="cov0" title="0">{
        _, exists := rh.strategies[err.Code]
        return exists
}</span>

// GetPriority implements ErrorHandler
func (rh *RecoveryHandler) GetPriority() int <span class="cov0" title="0">{
        return rh.priority
}</span>

// handleRetry implements retry logic
func (rh *RecoveryHandler) handleRetry(err *AppError) error <span class="cov0" title="0">{
        // In a real implementation, this would retry the failing operation
        // For now, we'll simulate a retry delay
        time.Sleep(time.Second * 2)
        return nil
}</span>

// handleFallback implements fallback logic
func (rh *RecoveryHandler) handleFallback(err *AppError) error <span class="cov0" title="0">{
        // In a real implementation, this would use a fallback mechanism
        // For example, use default values or alternative services
        return nil
}</span>

// LoggingHandler implements error logging functionality
type LoggingHandler struct {
        logger   *log.Logger
        priority int
}

// NewLoggingHandler creates a new logging handler
func NewLoggingHandler(logger *log.Logger) *LoggingHandler <span class="cov0" title="0">{
        return &amp;LoggingHandler{
                logger:   logger,
                priority: 50,
        }
}</span>

// Handle implements ErrorHandler
func (lh *LoggingHandler) Handle(err *AppError) error <span class="cov0" title="0">{
        lh.logger.Printf("Error handled: %s", err.Error())
        return nil
}</span>

// CanHandle implements ErrorHandler
func (lh *LoggingHandler) CanHandle(err *AppError) bool <span class="cov0" title="0">{
        return true // Handle all errors
}</span>

// GetPriority implements ErrorHandler
func (lh *LoggingHandler) GetPriority() int <span class="cov0" title="0">{
        return lh.priority
}</span>

// NotificationHandler implements error notification functionality
type NotificationHandler struct {
        notifier NotificationService
        priority int
}

// NotificationService defines the interface for notification services
type NotificationService interface {
        SendNotification(title, message string, severity ErrorSeverity) error
}

// NewNotificationHandler creates a new notification handler
func NewNotificationHandler(notifier NotificationService) *NotificationHandler <span class="cov0" title="0">{
        return &amp;NotificationHandler{
                notifier: notifier,
                priority: 200,
        }
}</span>

// Handle implements ErrorHandler
func (nh *NotificationHandler) Handle(err *AppError) error <span class="cov0" title="0">{
        if err.IsCritical() </span><span class="cov0" title="0">{
                title := fmt.Sprintf("Critical Error: %s", err.Code.String())
                message := fmt.Sprintf("Component: %s\nMessage: %s", err.Component, err.Message)
                return nh.notifier.SendNotification(title, message, err.Severity)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CanHandle implements ErrorHandler
func (nh *NotificationHandler) CanHandle(err *AppError) bool <span class="cov0" title="0">{
        return err.IsCritical()
}</span>

// GetPriority implements ErrorHandler
func (nh *NotificationHandler) GetPriority() int <span class="cov0" title="0">{
        return nh.priority
}</span>

// ErrorContext provides contextual information for error handling
type ErrorContext struct {
        Operation string                 `json:"operation"`
        UserID    string                 `json:"user_id,omitempty"`
        SessionID string                 `json:"session_id,omitempty"`
        RequestID string                 `json:"request_id,omitempty"`
        Component string                 `json:"component"`
        Metadata  map[string]interface{} `json:"metadata"`
        Timestamp time.Time              `json:"timestamp"`
}

// NewErrorContext creates a new error context
func NewErrorContext(operation, component string) *ErrorContext <span class="cov0" title="0">{
        return &amp;ErrorContext{
                Operation: operation,
                Component: component,
                Metadata:  make(map[string]interface{}),
                Timestamp: time.Now(),
        }
}</span>

// WithUser adds user information to the context
func (ec *ErrorContext) WithUser(userID string) *ErrorContext <span class="cov0" title="0">{
        ec.UserID = userID
        return ec
}</span>

// WithSession adds session information to the context
func (ec *ErrorContext) WithSession(sessionID string) *ErrorContext <span class="cov0" title="0">{
        ec.SessionID = sessionID
        return ec
}</span>

// WithRequest adds request information to the context
func (ec *ErrorContext) WithRequest(requestID string) *ErrorContext <span class="cov0" title="0">{
        ec.RequestID = requestID
        return ec
}</span>

// WithMetadata adds metadata to the context
func (ec *ErrorContext) WithMetadata(key string, value interface{}) *ErrorContext <span class="cov0" title="0">{
        if ec.Metadata == nil </span><span class="cov0" title="0">{
                ec.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">ec.Metadata[key] = value
        return ec</span>
}

// WrapError wraps an error with additional context
func WrapError(err error, context *ErrorContext) *AppError <span class="cov0" title="0">{
        if appErr, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                return appErr.WithContextMap(map[string]interface{}{
                        "operation": context.Operation,
                        "metadata":  context.Metadata,
                })
        }</span>

        // Create new error from standard error
        <span class="cov0" title="0">appErr := NewAppError(
                ErrComponentCreationFailed,
                err.Error(),
                context.Component,
                SeverityError,
        ).WithContextMap(map[string]interface{}{
                "operation": context.Operation,
                "metadata":  context.Metadata,
        })

        return appErr</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/components"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
)

// ViewType defines the different views/modes of the application
type ViewType int

const (
        FormView ViewType = iota
        LayoutView
        TabsView
        FilePickerView
        MenuView
)

// String returns the string representation of ViewType
func (vt ViewType) String() string <span class="cov0" title="0">{
        switch vt </span>{
        case FormView:<span class="cov0" title="0">
                return "form"</span>
        case LayoutView:<span class="cov0" title="0">
                return "layout"</span>
        case TabsView:<span class="cov0" title="0">
                return "tabs"</span>
        case FilePickerView:<span class="cov0" title="0">
                return "filepicker"</span>
        case MenuView:<span class="cov0" title="0">
                return "menu"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// AppMetadata contains comprehensive information about the application instance
type AppMetadata struct {
        Version      string    `json:"version"`
        BuildTime    string    `json:"build_time"`
        GitCommit    string    `json:"git_commit"`
        GoVersion    string    `json:"go_version"`
        Architecture string    `json:"architecture"`
        Platform     string    `json:"platform"`
        StartTime    time.Time `json:"start_time"`
        SessionID    string    `json:"session_id"`
}

// PerformanceMetrics tracks application performance indicators
type PerformanceMetrics struct {
        RenderCount     int           `json:"render_count"`
        TotalRenderTime time.Duration `json:"total_render_time"`
        AvgRenderTime   time.Duration `json:"avg_render_time"`
        LastUpdate      time.Time     `json:"last_update"`
        MemoryUsage     uint64        `json:"memory_usage"`
        GCCycles        uint32        `json:"gc_cycles"`
}

// ValidationState tracks the validation status across all components
type ValidationState struct {
        IsValid            bool                         `json:"is_valid"`
        TotalComponents    int                          `json:"total_components"`
        ValidComponents    int                          `json:"valid_components"`
        InvalidComponents  int                          `json:"invalid_components"`
        ComponentErrors    map[string][]ValidationError `json:"component_errors"`
        LastValidation     time.Time                    `json:"last_validation"`
        ValidationDuration time.Duration                `json:"validation_duration"`
}

// ValidationError represents a validation error with detailed information
type ValidationError struct {
        Code     string                 `json:"code"`
        Message  string                 `json:"message"`
        Field    string                 `json:"field"`
        Severity string                 `json:"severity"`
        Context  map[string]interface{} `json:"context"`
}

// AppModel is the central state management model for the entire application.
// It manages view transitions, global state, error handling, and coordinates
// between different orchestration models (FormModel, LayoutModel, TabsModel).
type AppModel struct {
        // Current application state
        currentView  ViewType `json:"current_view"`
        previousView ViewType `json:"previous_view"`

        // Active model instance (can be FormModel, LayoutModel, TabsModel, etc.)
        activeModel tea.Model `json:"-"` // Not serialized

        // Global application state
        config      *config.Config     `json:"config"`
        theme       *styles.Theme      `json:"theme"`
        metadata    AppMetadata        `json:"metadata"`
        performance PerformanceMetrics `json:"performance"`
        validation  ValidationState    `json:"validation"`

        // Error management
        errors      []AppError `json:"errors"`
        lastErrorID int        `json:"last_error_id"`

        // Component registry for dependency injection
        components map[string]components.Component `json:"-"` // Not serialized

        // Navigation state
        navigationHistory []ViewType `json:"navigation_history"`
        navigationIndex   int        `json:"navigation_index"`

        // Application lifecycle
        started  bool `json:"started"`
        quitting bool `json:"quitting"`
        debug    bool `json:"debug"`

        // Window and terminal state
        width         int  `json:"width"`
        height        int  `json:"height"`
        terminalReady bool `json:"terminal_ready"`
}

// AppError represents a structured application error with full context
type AppError struct {
        ID         string                 `json:"id"`
        Code       ErrorCode              `json:"code"`
        Message    string                 `json:"message"`
        Component  string                 `json:"component"`
        Severity   ErrorSeverity          `json:"severity"`
        Context    map[string]interface{} `json:"context"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Timestamp  time.Time              `json:"timestamp"`
        Resolved   bool                   `json:"resolved"`
}

// ErrorCode defines standardized error codes for the application
type ErrorCode int

const (
        ErrComponentNotFound ErrorCode = iota + 1000
        ErrValidationFailed
        ErrConfigInvalid
        ErrThemeLoadFailed
        ErrComponentCreationFailed
        ErrStateManagementFailed
        ErrSerializationFailed
        ErrFileOperationFailed
        ErrNetworkOperationFailed
        ErrPermissionDenied
        ErrResourceNotFound
        ErrTimeout
        ErrConcurrencyIssue
        ErrMemoryAllocationFailed
        ErrInvalidViewTransition
        ErrComponentDependencyFailed
)

// ErrorSeverity defines the severity levels for errors
type ErrorSeverity int

const (
        SeverityInfo ErrorSeverity = iota
        SeverityWarning
        SeverityError
        SeverityCritical
        SeverityFatal
)

// NewAppModel creates a new AppModel with the specified configuration
func NewAppModel(cfg *config.Config, theme *styles.Theme) (*AppModel, error) <span class="cov0" title="0">{
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro de validação da configuração: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()

        app := &amp;AppModel{
                currentView:  FormView, // Default to form view
                previousView: FormView,
                config:       cfg,
                theme:        theme,
                components:   make(map[string]components.Component),
                errors:       make([]AppError, 0),
                metadata: AppMetadata{
                        Version:   cfg.Global.Version,
                        StartTime: now,
                        SessionID: generateSessionID(),
                },
                performance: PerformanceMetrics{
                        LastUpdate: now,
                },
                validation: ValidationState{
                        IsValid:         false,
                        ComponentErrors: make(map[string][]ValidationError),
                },
                navigationHistory: make([]ViewType, 0),
                navigationIndex:   -1,
                width:             80,
                height:            24,
                debug:             cfg.Global.Debug,
        }

        // Initialize the first view based on configuration
        if err := app.initializeView(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao inicializar visão inicial: %w", err)
        }</span>

        <span class="cov0" title="0">return app, nil</span>
}

// generateSessionID generates a unique session identifier
func generateSessionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("shantilly_%d", time.Now().UnixNano())
}</span>

// initializeView initializes the current view based on the application state
func (app *AppModel) initializeView() error <span class="cov0" title="0">{
        switch app.currentView </span>{
        case FormView:<span class="cov0" title="0">
                if len(app.config.Forms) &gt; 0 </span><span class="cov0" title="0">{
                        formModel, err := NewFormModel(&amp;app.config.Forms[0], app.theme)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erro ao criar modelo de formulário: %w", err)
                        }</span>
                        <span class="cov0" title="0">app.activeModel = formModel</span>
                }

        case LayoutView:<span class="cov0" title="0">
                if len(app.config.Layouts) &gt; 0 </span><span class="cov0" title="0">{
                        layoutModel, err := NewLayoutModel(&amp;app.config.Layouts[0], app.theme)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erro ao criar modelo de layout: %w", err)
                        }</span>
                        <span class="cov0" title="0">app.activeModel = layoutModel</span>
                }

        case TabsView:<span class="cov0" title="0">
                if len(app.config.Tabs) &gt; 0 </span><span class="cov0" title="0">{
                        tabsModel, err := NewTabsModel(&amp;app.config.Tabs[0], app.theme)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erro ao criar modelo de abas: %w", err)
                        }</span>
                        <span class="cov0" title="0">app.activeModel = tabsModel</span>
                }

        default:<span class="cov0" title="0">
                return fmt.Errorf("tipo de visão não suportado: %s", app.currentView.String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Init implements tea.Model
func (app *AppModel) Init() tea.Cmd <span class="cov0" title="0">{
        if app.activeModel != nil </span><span class="cov0" title="0">{
                return app.activeModel.Init()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update implements tea.Model
func (app *AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        startTime := time.Now()

        // Handle global messages first
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                app.width = msg.Width
                app.height = msg.Height
                app.terminalReady = true

                // Propagate to active model
                if app.activeModel != nil </span><span class="cov0" title="0">{
                        return app.activeModel.Update(msg)
                }</span>
                <span class="cov0" title="0">return app, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "ctrl+c", "esc":<span class="cov0" title="0">
                        app.quitting = true
                        return app, tea.Quit</span>

                case "F1":<span class="cov0" title="0">
                        // Debug information toggle
                        app.debug = !app.debug
                        return app, nil</span>

                case "F2":<span class="cov0" title="0">
                        // View navigation (for testing)
                        return app, app.navigateToNextView()</span>

                case "F12":<span class="cov0" title="0">
                        // Show application statistics
                        app.logAppStats()
                        return app, nil</span>
                }
        }

        // Update active model
        <span class="cov0" title="0">if app.activeModel != nil </span><span class="cov0" title="0">{
                updatedModel, cmd := app.activeModel.Update(msg)
                if updatedModel != nil </span><span class="cov0" title="0">{
                        app.activeModel = updatedModel
                }</span>

                // Update performance metrics
                <span class="cov0" title="0">updateDuration := time.Since(startTime)
                app.performance.TotalRenderTime += updateDuration
                app.performance.RenderCount++
                app.performance.AvgRenderTime = app.performance.TotalRenderTime / time.Duration(app.performance.RenderCount)
                app.performance.LastUpdate = time.Now()

                return app, cmd</span>
        }

        <span class="cov0" title="0">return app, nil</span>
}

// View implements tea.Model
func (app *AppModel) View() string <span class="cov0" title="0">{
        if app.quitting </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if !app.terminalReady </span><span class="cov0" title="0">{
                return "Inicializando terminal..."
        }</span>

        <span class="cov0" title="0">var sections []string

        // Application header with metadata
        if app.debug </span><span class="cov0" title="0">{
                sections = append(sections, app.renderDebugHeader())
        }</span>

        // Main content from active model
        <span class="cov0" title="0">if app.activeModel != nil </span><span class="cov0" title="0">{
                // Type assertion to access View method
                if modelWithView, ok := app.activeModel.(interface{ View() string }); ok </span><span class="cov0" title="0">{
                        content := modelWithView.View()
                        sections = append(sections, content)
                }</span>
        }

        // Error display
        <span class="cov0" title="0">if len(app.errors) &gt; 0 </span><span class="cov0" title="0">{
                errorSection := app.renderErrors()
                sections = append(sections, errorSection)
        }</span>

        // Debug footer
        <span class="cov0" title="0">if app.debug </span><span class="cov0" title="0">{
                sections = append(sections, app.renderDebugFooter())
        }</span>

        // Global navigation help
        <span class="cov0" title="0">sections = append(sections, app.renderGlobalHelp())

        return app.theme.Border.Render(lipgloss.JoinVertical(lipgloss.Left, sections...))</span>
}

// renderDebugHeader renders debug information in the header
func (app *AppModel) renderDebugHeader() string <span class="cov0" title="0">{
        header := fmt.Sprintf("Shantilly v%s | View: %s | Components: %d | Errors: %d",
                app.metadata.Version,
                app.currentView.String(),
                len(app.components),
                len(app.errors),
        )
        return fmt.Sprintf("\x1b[36m%s\x1b[0m", header) // Cyan color for debug info
}</span>

// renderErrors renders current application errors
func (app *AppModel) renderErrors() string <span class="cov0" title="0">{
        var errorLines []string
        for _, err := range app.errors </span><span class="cov0" title="0">{
                if !err.Resolved </span><span class="cov0" title="0">{
                        errorLine := fmt.Sprintf("✗ %s: %s", err.Code.String(), err.Message)
                        errorLines = append(errorLines, errorLine)
                }</span>
        }
        <span class="cov0" title="0">return app.theme.Error.Render(strings.Join(errorLines, "\n"))</span>
}

// renderDebugFooter renders debug information in the footer
func (app *AppModel) renderDebugFooter() string <span class="cov0" title="0">{
        footer := fmt.Sprintf("Performance: %v avg render | Memory: %d MB | Validation: %s",
                app.performance.AvgRenderTime.Round(time.Millisecond),
                app.performance.MemoryUsage/1024/1024,
                map[bool]string{true: "✓", false: "✗"}[app.validation.IsValid],
        )
        return fmt.Sprintf("\x1b[36m%s\x1b[0m", footer) // Cyan color for debug info
}</span>

// renderGlobalHelp renders global navigation help
func (app *AppModel) renderGlobalHelp() string <span class="cov0" title="0">{
        help := "F1: Debug | F2: Next View | F12: Stats | Esc: Quit"
        return app.theme.Help.Render(help)
}</span>

// navigateToNextView handles view transitions
func (app *AppModel) navigateToNextView() tea.Cmd <span class="cov0" title="0">{
        app.previousView = app.currentView

        // Cycle through available views
        switch app.currentView </span>{
        case FormView:<span class="cov0" title="0">
                if len(app.config.Layouts) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = LayoutView
                }</span> else<span class="cov0" title="0"> if len(app.config.Tabs) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = TabsView
                }</span>
        case LayoutView:<span class="cov0" title="0">
                if len(app.config.Tabs) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = TabsView
                }</span> else<span class="cov0" title="0"> if len(app.config.Forms) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = FormView
                }</span>
        case TabsView:<span class="cov0" title="0">
                if len(app.config.Forms) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = FormView
                }</span> else<span class="cov0" title="0"> if len(app.config.Layouts) &gt; 0 </span><span class="cov0" title="0">{
                        app.currentView = LayoutView
                }</span>
        }

        // Add to navigation history
        <span class="cov0" title="0">app.navigationHistory = append(app.navigationHistory, app.currentView)
        app.navigationIndex++

        // Reinitialize the view
        return func() tea.Msg </span><span class="cov0" title="0">{
                if err := app.initializeView(); err != nil </span><span class="cov0" title="0">{
                        app.addError(ErrStateManagementFailed, "Failed to initialize view", "AppModel", SeverityError, map[string]interface{}{
                                "from_view": app.previousView.String(),
                                "to_view":   app.currentView.String(),
                                "error":     err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// addError adds a new error to the application error list
func (app *AppModel) addError(code ErrorCode, message, component string, severity ErrorSeverity, context map[string]interface{}) <span class="cov0" title="0">{
        app.lastErrorID++
        error := AppError{
                ID:        fmt.Sprintf("err_%d", app.lastErrorID),
                Code:      code,
                Message:   message,
                Component: component,
                Severity:  severity,
                Context:   context,
                Timestamp: time.Now(),
                Resolved:  false,
        }
        app.errors = append(app.errors, error)
}</span>

// resolveError marks an error as resolved
func (app *AppModel) resolveError(errorID string) <span class="cov0" title="0">{
        for i := range app.errors </span><span class="cov0" title="0">{
                if app.errors[i].ID == errorID </span><span class="cov0" title="0">{
                        app.errors[i].Resolved = true
                        break</span>
                }
        }
}

// logAppStats logs current application statistics for debugging
func (app *AppModel) logAppStats() <span class="cov0" title="0">{
        stats := map[string]interface{}{
                "current_view":     app.currentView.String(),
                "components_count": len(app.components),
                "errors_count":     len(app.errors),
                "performance":      app.performance,
                "validation":       app.validation,
                "navigation_depth": len(app.navigationHistory),
                "terminal_size":    fmt.Sprintf("%dx%d", app.width, app.height),
        }

        if data, err := json.MarshalIndent(stats, "", "  "); err == nil </span><span class="cov0" title="0">{
                // In a real implementation, this would be logged
                fmt.Printf("App Stats: %s\n", string(data))
        }</span>
}

// GetCurrentView returns the current view type
func (app *AppModel) GetCurrentView() ViewType <span class="cov0" title="0">{
        return app.currentView
}</span>

// GetActiveModel returns the currently active model
func (app *AppModel) GetActiveModel() tea.Model <span class="cov0" title="0">{
        return app.activeModel
}</span>

// GetErrors returns all unresolved errors
func (app *AppModel) GetErrors() []AppError <span class="cov0" title="0">{
        var unresolved []AppError
        for _, err := range app.errors </span><span class="cov0" title="0">{
                if !err.Resolved </span><span class="cov0" title="0">{
                        unresolved = append(unresolved, err)
                }</span>
        }
        <span class="cov0" title="0">return unresolved</span>
}

// IsQuitting returns true if the application is quitting
func (app *AppModel) IsQuitting() bool <span class="cov0" title="0">{
        return app.quitting
}</span>

// String returns a string representation of the ErrorCode
func (ec ErrorCode) String() string <span class="cov0" title="0">{
        switch ec </span>{
        case ErrComponentNotFound:<span class="cov0" title="0">
                return "COMPONENT_NOT_FOUND"</span>
        case ErrValidationFailed:<span class="cov0" title="0">
                return "VALIDATION_FAILED"</span>
        case ErrConfigInvalid:<span class="cov0" title="0">
                return "CONFIG_INVALID"</span>
        case ErrThemeLoadFailed:<span class="cov0" title="0">
                return "THEME_LOAD_FAILED"</span>
        case ErrComponentCreationFailed:<span class="cov0" title="0">
                return "COMPONENT_CREATION_FAILED"</span>
        case ErrStateManagementFailed:<span class="cov0" title="0">
                return "STATE_MANAGEMENT_FAILED"</span>
        case ErrSerializationFailed:<span class="cov0" title="0">
                return "SERIALIZATION_FAILED"</span>
        case ErrFileOperationFailed:<span class="cov0" title="0">
                return "FILE_OPERATION_FAILED"</span>
        case ErrNetworkOperationFailed:<span class="cov0" title="0">
                return "NETWORK_OPERATION_FAILED"</span>
        case ErrPermissionDenied:<span class="cov0" title="0">
                return "PERMISSION_DENIED"</span>
        case ErrResourceNotFound:<span class="cov0" title="0">
                return "RESOURCE_NOT_FOUND"</span>
        case ErrTimeout:<span class="cov0" title="0">
                return "TIMEOUT"</span>
        case ErrConcurrencyIssue:<span class="cov0" title="0">
                return "CONCURRENCY_ISSUE"</span>
        case ErrMemoryAllocationFailed:<span class="cov0" title="0">
                return "MEMORY_ALLOCATION_FAILED"</span>
        case ErrInvalidViewTransition:<span class="cov0" title="0">
                return "INVALID_VIEW_TRANSITION"</span>
        case ErrComponentDependencyFailed:<span class="cov0" title="0">
                return "COMPONENT_DEPENDENCY_FAILED"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("UNKNOWN_ERROR_%d", int(ec))</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "log"
        "time"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/components"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/errors"
        "github.com/helton/shantilly/internal/styles"
)

// FormModel orchestrates multiple components in a form layout.
// It manages focus navigation, validation aggregation, and JSON serialization.
type FormModel struct {
        title       string
        description string
        components  []components.Component
        focusIndex  int
        theme       *styles.Theme
        width       int
        height      int
        submitted   bool
        quitting    bool

        // Error management integration
        errorManager *errors.ErrorManager

        // AppModel reference for integration
        appModel *AppModel
}

// NewFormModel creates a new FormModel from configuration.
func NewFormModel(cfg *config.FormConfig, theme *styles.Theme) (*FormModel, error) <span class="cov10" title="15">{
        if err := cfg.Validate(); err != nil </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("erro de validação da configuração do formulário: %w", err)
        }</span>

        // Create components using factory
        <span class="cov9" title="12">comps, err := components.NewComponents(cfg.Components, theme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao criar componentes: %w", err)
        }</span>

        // Find first focusable component
        <span class="cov9" title="12">focusIndex := -1
        for i, comp := range comps </span><span class="cov9" title="13">{
                if comp.CanFocus() </span><span class="cov8" title="10">{
                        focusIndex = i
                        break</span>
                }
        }

        <span class="cov9" title="12">m := &amp;FormModel{
                title:       cfg.Title,
                description: cfg.Description,
                components:  comps,
                focusIndex:  focusIndex,
                theme:       theme,
                width:       80,
                height:      24,
        }

        // Set initial focus
        if focusIndex &gt;= 0 </span><span class="cov8" title="10">{
                m.components[focusIndex].SetFocus(true)
        }</span>

        <span class="cov9" title="12">return m, nil</span>
}

// SetErrorManager configura o ErrorManager para o modelo de formulário
func (m *FormModel) SetErrorManager(em *errors.ErrorManager) <span class="cov0" title="0">{
        m.errorManager = em
        // Propagate ErrorManager to all components
        for _, comp := range m.components </span><span class="cov0" title="0">{
                if textInput, ok := comp.(*components.TextInput); ok </span><span class="cov0" title="0">{
                        textInput.SetErrorManager(em)
                }</span>
                <span class="cov0" title="0">if textArea, ok := comp.(*components.TextArea); ok </span><span class="cov0" title="0">{
                        textArea.SetErrorManager(em)
                }</span>
        }
}

// SetAppModel configura a referência ao AppModel para integração
func (m *FormModel) SetAppModel(appModel *AppModel) <span class="cov0" title="0">{
        m.appModel = appModel
}</span>

// Init implements tea.Model.
func (m *FormModel) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (m *FormModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov3" title="2">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Propagate window size to all components
                m.width = msg.Width
                m.height = msg.Height
                for i := range m.components </span><span class="cov0" title="0">{
                        if _, err := m.components[i].Update(msg); err != nil </span><span class="cov0" title="0">{
                                return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        return fmt.Errorf("erro ao atualizar componente %d com redimensionamento: componente retornou erro não tratado", i)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>

        case tea.KeyMsg:<span class="cov3" title="2">
                switch msg.String() </span>{
                case "ctrl+c", "esc":<span class="cov0" title="0">
                        m.quitting = true
                        return m, tea.Quit</span>

                case "tab":<span class="cov0" title="0">
                        m.focusNext()
                        return m, nil</span>

                case "shift+tab":<span class="cov0" title="0">
                        m.focusPrev()
                        return m, nil</span>

                case "enter":<span class="cov1" title="1">
                        // Check if form can be submitted
                        if m.CanSubmit() </span><span class="cov0" title="0">{
                                m.submitted = true
                                return m, tea.Quit
                        }</span>
                        // If not valid, validate all to show errors
                        <span class="cov1" title="1">m.validateAll()
                        return m, nil</span>
                }
        }

        // Propagate message to focused component with ErrorManager integration
        <span class="cov1" title="1">if m.focusIndex &gt;= 0 &amp;&amp; m.focusIndex &lt; len(m.components) </span><span class="cov1" title="1">{
                var cmd tea.Cmd
                updated, cmd := m.components[m.focusIndex].Update(msg)
                if updatedModel, ok := updated.(components.Component); ok </span><span class="cov1" title="1">{
                        m.components[m.focusIndex] = updatedModel

                        // Update AppModel state if available
                        if m.appModel != nil </span><span class="cov0" title="0">{
                                // Update form state in AppModel
                                m.updateAppModelState()
                        }</span>

                        <span class="cov1" title="1">return m, cmd</span>
                } else<span class="cov0" title="0"> {
                        // Enhanced error handling with ErrorManager
                        errMsg := fmt.Sprintf("erro ao atualizar componente %d: modelo inválido retornado", m.focusIndex)

                        if m.errorManager != nil </span><span class="cov0" title="0">{
                                log.Printf("FormModel component update error: %s", errMsg)
                        }</span>

                        <span class="cov0" title="0">return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return fmt.Errorf("erro ao atualizar componente %d: modelo inválido retornado", m.focusIndex)
                        }</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

// updateAppModelState updates the AppModel with current form state
func (m *FormModel) updateAppModelState() <span class="cov0" title="0">{
        if m.appModel == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update validation state
        <span class="cov0" title="0">m.appModel.validation.TotalComponents = len(m.components)
        m.appModel.validation.ValidComponents = 0
        m.appModel.validation.InvalidComponents = 0
        m.appModel.validation.ComponentErrors = make(map[string][]ValidationError)

        for _, comp := range m.components </span><span class="cov0" title="0">{
                if comp.IsValid() </span><span class="cov0" title="0">{
                        m.appModel.validation.ValidComponents++
                }</span> else<span class="cov0" title="0"> {
                        m.appModel.validation.InvalidComponents++

                        // Collect validation errors using components package types
                        comp.ValidateWithContext(components.ValidationContext{
                                ComponentValues: m.ToMap(),
                        })
                        // Simplified error collection to avoid type conflicts
                        m.appModel.validation.ComponentErrors[comp.Name()] = []ValidationError{}
                }</span>
        }

        <span class="cov0" title="0">m.appModel.validation.IsValid = m.appModel.validation.InvalidComponents == 0
        m.appModel.validation.LastValidation = time.Now()</span>
}

// View implements tea.Model.
func (m *FormModel) View() string <span class="cov1" title="1">{
        if m.quitting </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">var sections []string

        // Title
        if m.title != "" </span><span class="cov1" title="1">{
                sections = append(sections, m.theme.Title.Render(m.title))
        }</span>

        // Description
        <span class="cov1" title="1">if m.description != "" </span><span class="cov0" title="0">{
                sections = append(sections, m.theme.Description.Render(m.description))
        }</span>

        // Components (without individual borders - only the form container has a border)
        <span class="cov1" title="1">for i, comp := range m.components </span><span class="cov1" title="1">{
                view := comp.View()

                // Apply consistent border-based focus indicator (same as LayoutModel)
                if i == m.focusIndex &amp;&amp; comp.CanFocus() </span><span class="cov1" title="1">{
                        view = m.theme.BorderActive.Render(view)
                }</span> else<span class="cov0" title="0"> {
                        view = m.theme.Border.Render(view)
                }</span>

                <span class="cov1" title="1">sections = append(sections, view)</span>
        }

        // Submit help
        <span class="cov1" title="1">if m.CanSubmit() </span><span class="cov1" title="1">{
                sections = append(sections, m.theme.Help.Render("Pressione Enter para submeter"))
        }</span> else<span class="cov0" title="0"> {
                sections = append(sections, m.theme.Error.Render("Complete todos os campos obrigatórios"))
        }</span>

        // Navigation help
        <span class="cov1" title="1">sections = append(sections, m.theme.Help.Render("Tab/Shift+Tab: Navegar | Esc: Sair"))

        // Don't apply border to container since individual components now have borders
        return lipgloss.JoinVertical(lipgloss.Left, sections...)</span>
}

// focusNext moves focus to the next focusable component.
func (m *FormModel) focusNext() <span class="cov0" title="0">{
        if m.focusIndex &gt;= 0 </span><span class="cov0" title="0">{
                m.components[m.focusIndex].SetFocus(false)
        }</span>

        // Find next focusable component
        <span class="cov0" title="0">start := m.focusIndex + 1
        for i := 0; i &lt; len(m.components); i++ </span><span class="cov0" title="0">{
                idx := (start + i) % len(m.components)
                if m.components[idx].CanFocus() </span><span class="cov0" title="0">{
                        m.focusIndex = idx
                        m.components[idx].SetFocus(true)
                        return
                }</span>
        }
}

// focusPrev moves focus to the previous focusable component.
func (m *FormModel) focusPrev() <span class="cov0" title="0">{
        if m.focusIndex &gt;= 0 </span><span class="cov0" title="0">{
                m.components[m.focusIndex].SetFocus(false)
        }</span>

        // Find previous focusable component
        <span class="cov0" title="0">start := m.focusIndex - 1
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = len(m.components) - 1
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(m.components); i++ </span><span class="cov0" title="0">{
                idx := start - i
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        idx += len(m.components)
                }</span>
                <span class="cov0" title="0">if m.components[idx].CanFocus() </span><span class="cov0" title="0">{
                        m.focusIndex = idx
                        m.components[idx].SetFocus(true)
                        return
                }</span>
        }
}

// CanSubmit returns true if all components are valid.
func (m *FormModel) CanSubmit() bool <span class="cov7" title="7">{
        allValid := true
        for _, comp := range m.components </span><span class="cov10" title="15">{
                if !comp.IsValid() </span><span class="cov6" title="5">{
                        allValid = false

                        // Log validation error if ErrorManager is available
                        if m.errorManager != nil </span><span class="cov0" title="0">{
                                log.Printf("FormModel validation error in component %s: componente inválido", comp.Name())
                        }</span>
                }
        }

        // Update AppModel validation state
        <span class="cov7" title="7">if m.appModel != nil </span><span class="cov0" title="0">{
                m.updateAppModelState()
        }</span>

        <span class="cov7" title="7">return allValid</span>
}

// validateAll validates all components to trigger error display.
func (m *FormModel) validateAll() <span class="cov4" title="3">{
        for _, comp := range m.components </span><span class="cov4" title="3">{
                comp.IsValid()
        }</span>
}

// Submitted returns true if the form was successfully submitted.
func (m *FormModel) Submitted() bool <span class="cov4" title="3">{
        return m.submitted
}</span>

// ToJSON serializes the form data to JSON.
// Returns a JSON byte array with component names as keys and values.
func (m *FormModel) ToJSON() ([]byte, error) <span class="cov4" title="3">{
        data := make(map[string]interface{})

        for _, comp := range m.components </span><span class="cov6" title="5">{
                data[comp.Name()] = comp.Value()
        }</span>

        <span class="cov4" title="3">jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("erro ao serializar dados: %w", err)
        }</span>

        <span class="cov1" title="1">return jsonData, nil</span>
}

// ToMap returns the form data as a map for programmatic access.
func (m *FormModel) ToMap() map[string]interface{} <span class="cov1" title="1">{
        data := make(map[string]interface{})

        for _, comp := range m.components </span><span class="cov3" title="2">{
                data[comp.Name()] = comp.Value()
        }</span>

        <span class="cov1" title="1">return data</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/components"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
)

// LayoutModel orchestrates components in a horizontal or vertical layout.
// It manages focus navigation and responsive resizing.
type LayoutModel struct {
        title       string
        description string
        layout      string // "horizontal" or "vertical"
        components  []components.Component
        focusIndex  int
        theme       *styles.Theme
        width       int
        height      int
        quitting    bool
}

// NewLayoutModel creates a new LayoutModel from configuration.
func NewLayoutModel(cfg *config.LayoutConfig, theme *styles.Theme) (*LayoutModel, error) <span class="cov10" title="22">{
        if err := cfg.Validate(); err != nil </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("erro de validação da configuração do layout: %w", err)
        }</span>

        // Create components using factory
        <span class="cov9" title="19">comps, err := components.NewComponents(cfg.Components, theme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erro ao criar componentes: %w", err)
        }</span>

        // Find first focusable component
        <span class="cov9" title="19">focusIndex := -1
        for i, comp := range comps </span><span class="cov9" title="20">{
                if comp.CanFocus() </span><span class="cov9" title="16">{
                        focusIndex = i
                        break</span>
                }
        }

        <span class="cov9" title="19">m := &amp;LayoutModel{
                title:       cfg.Title,
                description: cfg.Description,
                layout:      cfg.Layout,
                components:  comps,
                focusIndex:  focusIndex,
                theme:       theme,
                width:       80,
                height:      24,
        }

        // Set initial focus
        if focusIndex &gt;= 0 </span><span class="cov9" title="16">{
                m.components[focusIndex].SetFocus(true)
        }</span>

        <span class="cov9" title="19">return m, nil</span>
}

// Init implements tea.Model.
func (m *LayoutModel) Init() tea.Cmd <span class="cov1" title="1">{
        return nil
}</span>

// Update implements tea.Model.
func (m *LayoutModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="12">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov7" title="8">
                // Propagate window size to all components for responsive layout
                m.width = msg.Width
                m.height = msg.Height
                for i := range m.components </span><span class="cov9" title="16">{
                        if _, err := m.components[i].Update(msg); err != nil </span><span class="cov0" title="0">{
                                return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        return fmt.Errorf("erro ao atualizar componente %d com redimensionamento: componente retornou erro não tratado", i)
                                }</span>
                        }
                }
                <span class="cov7" title="8">return m, nil</span>

        case tea.KeyMsg:<span class="cov5" title="4">
                switch msg.String() </span>{
                case "ctrl+c", "esc":<span class="cov1" title="1">
                        m.quitting = true
                        return m, tea.Quit</span>

                case "tab":<span class="cov1" title="1">
                        m.focusNext()
                        return m, nil</span>

                case "shift+tab":<span class="cov0" title="0">
                        m.focusPrev()
                        return m, nil</span>
                }
        }

        // Propagate message to focused component
        <span class="cov3" title="2">if m.focusIndex &gt;= 0 &amp;&amp; m.focusIndex &lt; len(m.components) </span><span class="cov3" title="2">{
                var cmd tea.Cmd
                updated, cmd := m.components[m.focusIndex].Update(msg)
                if updatedModel, ok := updated.(components.Component); ok </span><span class="cov3" title="2">{
                        m.components[m.focusIndex] = updatedModel
                        return m, cmd
                }</span> else<span class="cov0" title="0"> {
                        // Log error and return unchanged model
                        return m, func() tea.Msg </span><span class="cov0" title="0">{
                                return fmt.Errorf("erro ao atualizar componente %d: modelo inválido retornado", m.focusIndex)
                        }</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View implements tea.Model.
func (m *LayoutModel) View() string <span class="cov8" title="12">{
        if m.quitting </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="12">var sections []string

        // Title
        if m.title != "" </span><span class="cov8" title="12">{
                sections = append(sections, m.theme.Title.Render(m.title))
        }</span>

        // Description
        <span class="cov8" title="12">if m.description != "" </span><span class="cov1" title="1">{
                sections = append(sections, m.theme.Description.Render(m.description))
        }</span>

        // Render components according to layout
        <span class="cov8" title="12">var componentsView string
        if m.layout == "horizontal" </span><span class="cov7" title="10">{
                componentsView = m.renderHorizontal()
        }</span> else<span class="cov3" title="2"> {
                componentsView = m.renderVertical()
        }</span>
        <span class="cov8" title="12">sections = append(sections, componentsView)

        // Navigation help
        sections = append(sections, m.theme.Help.Render("Tab/Shift+Tab: Navegar | Esc: Sair"))

        return m.theme.Border.Render(lipgloss.JoinVertical(lipgloss.Left, sections...))</span>
}

// renderHorizontal renders components in horizontal layout.
// This is the ONLY place where borders are applied to components.
func (m *LayoutModel) renderHorizontal() string <span class="cov7" title="10">{
        var views []string
        for i, comp := range m.components </span><span class="cov9" title="20">{
                view := comp.View()

                // Apply border based on focus state
                if i == m.focusIndex &amp;&amp; comp.CanFocus() </span><span class="cov7" title="10">{
                        view = m.theme.BorderActive.Render(view)
                }</span> else<span class="cov7" title="10"> {
                        view = m.theme.Border.Render(view)
                }</span>
                <span class="cov9" title="20">views = append(views, view)</span>
        }
        <span class="cov7" title="10">return lipgloss.JoinHorizontal(lipgloss.Top, views...)</span>
}

// renderVertical renders components in vertical layout.
// This is the ONLY place where borders are applied to components.
func (m *LayoutModel) renderVertical() string <span class="cov3" title="2">{
        var views []string
        for i, comp := range m.components </span><span class="cov5" title="4">{
                view := comp.View()

                // Apply border based on focus state
                if i == m.focusIndex &amp;&amp; comp.CanFocus() </span><span class="cov3" title="2">{
                        view = m.theme.BorderActive.Render(view)
                }</span> else<span class="cov3" title="2"> {
                        view = m.theme.Border.Render(view)
                }</span>
                <span class="cov5" title="4">views = append(views, view)</span>
        }
        <span class="cov3" title="2">return lipgloss.JoinVertical(lipgloss.Left, views...)</span>
}

// focusNext moves focus to the next focusable component.
func (m *LayoutModel) focusNext() <span class="cov1" title="1">{
        if m.focusIndex &gt;= 0 </span><span class="cov0" title="0">{
                m.components[m.focusIndex].SetFocus(false)
        }</span>

        // Find next focusable component
        <span class="cov1" title="1">start := m.focusIndex + 1
        for i := 0; i &lt; len(m.components); i++ </span><span class="cov1" title="1">{
                idx := (start + i) % len(m.components)
                if m.components[idx].CanFocus() </span><span class="cov0" title="0">{
                        m.focusIndex = idx
                        m.components[idx].SetFocus(true)
                        return
                }</span>
        }
}

// focusPrev moves focus to the previous focusable component.
func (m *LayoutModel) focusPrev() <span class="cov0" title="0">{
        if m.focusIndex &gt;= 0 </span><span class="cov0" title="0">{
                m.components[m.focusIndex].SetFocus(false)
        }</span>

        // Find previous focusable component
        <span class="cov0" title="0">start := m.focusIndex - 1
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = len(m.components) - 1
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(m.components); i++ </span><span class="cov0" title="0">{
                idx := start - i
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        idx += len(m.components)
                }</span>
                <span class="cov0" title="0">if m.components[idx].CanFocus() </span><span class="cov0" title="0">{
                        m.focusIndex = idx
                        m.components[idx].SetFocus(true)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea/v2"
        "github.com/charmbracelet/lipgloss/v2"
        "github.com/helton/shantilly/internal/components"
        "github.com/helton/shantilly/internal/config"
        "github.com/helton/shantilly/internal/styles"
)

// TabsModel orchestrates components in a tabbed interface.
// It manages tab navigation and component focus within tabs.
type TabsModel struct {
        name       string
        label      string
        tabs       []TabData
        activeTab  int // Index of currently active tab
        theme      *styles.Theme
        errorMsg   string
        focused    bool
        initialTab int
}

// TabData represents a single tab with its components
type TabData struct {
        Name       string
        Label      string
        Components []components.Component
}

// NewTabsModel creates a new TabsModel from configuration.
func NewTabsModel(cfg *config.TabsConfig, theme *styles.Theme) (*TabsModel, error) <span class="cov0" title="0">{
        if len(cfg.Tabs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tabs deve conter pelo menos uma aba")
        }</span>

        <span class="cov0" title="0">tabs := make([]TabData, 0, len(cfg.Tabs))

        for _, tabCfg := range cfg.Tabs </span><span class="cov0" title="0">{
                // Create components for this tab using the factory
                components, err := components.NewComponents(tabCfg.Components, theme)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erro ao criar componentes para aba %s: %w", tabCfg.Name, err)
                }</span>

                <span class="cov0" title="0">tabData := TabData{
                        Name:       tabCfg.Name,
                        Label:      tabCfg.Label,
                        Components: components,
                }

                tabs = append(tabs, tabData)</span>
        }

        <span class="cov0" title="0">t := &amp;TabsModel{
                name:       "tabs", // Tabs model has a fixed name
                label:      cfg.Title,
                tabs:       tabs,
                activeTab:  0,
                theme:      theme,
                initialTab: 0,
        }

        return t, nil</span>
}

// Init implements tea.Model.
func (t *TabsModel) Init() tea.Cmd <span class="cov0" title="0">{
        // Initialize all components in the active tab
        var cmds []tea.Cmd
        for _, comp := range t.tabs[t.activeTab].Components </span><span class="cov0" title="0">{
                cmds = append(cmds, comp.Init())
        }</span>
        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

// Update implements tea.Model.
func (t *TabsModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if !t.focused </span><span class="cov0" title="0">{
                // Even if not focused, propagate messages to active tab components
                if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov0" title="0">{
                        for i, comp := range t.tabs[t.activeTab].Components </span><span class="cov0" title="0">{
                                updated, cmd := comp.Update(msg)
                                if updatedModel, ok := updated.(components.Component); ok </span><span class="cov0" title="0">{
                                        t.tabs[t.activeTab].Components[i] = updatedModel
                                        return t, cmd
                                }</span>
                        }
                }
                <span class="cov0" title="0">return t, nil</span>
        }

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "left", "h":<span class="cov0" title="0">
                        if t.activeTab &gt; 0 </span><span class="cov0" title="0">{
                                t.activeTab--
                        }</span>
                case "right", "l":<span class="cov0" title="0">
                        if t.activeTab &lt; len(t.tabs)-1 </span><span class="cov0" title="0">{
                                t.activeTab++
                        }</span>
                case "tab":<span class="cov0" title="0">
                        // Tab navigation within the active tab
                        t.focusNextInActiveTab()
                        return t, nil</span>
                case "shift+tab":<span class="cov0" title="0">
                        // Reverse tab navigation within the active tab
                        t.focusPrevInActiveTab()
                        return t, nil</span>
                }
        }

        // Propagate message to focused component in active tab
        <span class="cov0" title="0">if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov0" title="0">{
                tab := &amp;t.tabs[t.activeTab]
                for i, comp := range tab.Components </span><span class="cov0" title="0">{
                        if comp.CanFocus() </span><span class="cov0" title="0">{
                                updated, cmd := comp.Update(msg)
                                if updatedModel, ok := updated.(components.Component); ok </span><span class="cov0" title="0">{
                                        tab.Components[i] = updatedModel
                                        return t, cmd
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return t, nil</span>
}

// View implements tea.Model.
func (t *TabsModel) View() string <span class="cov0" title="0">{
        var b strings.Builder

        // Render tab headers
        tabHeaders := t.renderTabHeaders()
        b.WriteString(tabHeaders)
        b.WriteString("\n")

        // Render active tab content
        if t.activeTab &gt;= 0 &amp;&amp; t.activeTab &lt; len(t.tabs) </span><span class="cov0" title="0">{
                activeTabContent := t.renderActiveTab()
                b.WriteString(activeTabContent)
        }</span>

        // Render error message if present
        <span class="cov0" title="0">if t.errorMsg != "" </span><span class="cov0" title="0">{
                b.WriteString("\n")
                b.WriteString(t.theme.Error.Render("✗ " + t.errorMsg))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

// renderTabHeaders renders the tab navigation header.
func (t *TabsModel) renderTabHeaders() string <span class="cov0" title="0">{
        var headers []string

        for i, tab := range t.tabs </span><span class="cov0" title="0">{
                var header string

                // Tab label
                if i == t.activeTab </span><span class="cov0" title="0">{
                        header = t.theme.TabActive.Render(fmt.Sprintf(" %s ", tab.Label))
                }</span> else<span class="cov0" title="0"> {
                        header = t.theme.TabInactive.Render(fmt.Sprintf(" %s ", tab.Label))
                }</span>

                <span class="cov0" title="0">headers = append(headers, header)</span>
        }

        <span class="cov0" title="0">return lipgloss.JoinHorizontal(lipgloss.Top, headers...)</span>
}

// renderActiveTab renders the content of the currently active tab.
func (t *TabsModel) renderActiveTab() string <span class="cov0" title="0">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">tab := &amp;t.tabs[t.activeTab]
        var componentsView []string

        for i, comp := range tab.Components </span><span class="cov0" title="0">{
                view := comp.View()

                // Apply border based on focus state (similar to other models)
                if i == t.getFocusedComponentIndex() &amp;&amp; comp.CanFocus() </span><span class="cov0" title="0">{
                        view = t.theme.BorderActive.Render(view)
                }</span> else<span class="cov0" title="0"> {
                        view = t.theme.Border.Render(view)
                }</span>

                <span class="cov0" title="0">componentsView = append(componentsView, view)</span>
        }

        <span class="cov0" title="0">return lipgloss.JoinVertical(lipgloss.Left, componentsView...)</span>
}

// getFocusedComponentIndex returns the index of the currently focused component in the active tab.
func (t *TabsModel) getFocusedComponentIndex() int <span class="cov0" title="0">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">tab := &amp;t.tabs[t.activeTab]
        for i, comp := range tab.Components </span><span class="cov0" title="0">{
                if comp.CanFocus() </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// focusNextInActiveTab moves focus to the next focusable component in the active tab.
func (t *TabsModel) focusNextInActiveTab() <span class="cov0" title="0">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tab := &amp;t.tabs[t.activeTab]
        for _, comp := range tab.Components </span><span class="cov0" title="0">{
                if comp.CanFocus() </span><span class="cov0" title="0">{
                        comp.SetFocus(true)
                        break</span>
                }
        }
}

// focusPrevInActiveTab moves focus to the previous focusable component in the active tab.
func (t *TabsModel) focusPrevInActiveTab() <span class="cov0" title="0">{
        if t.activeTab &lt; 0 || t.activeTab &gt;= len(t.tabs) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tab := &amp;t.tabs[t.activeTab]
        for i := len(tab.Components) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if tab.Components[i].CanFocus() </span><span class="cov0" title="0">{
                        tab.Components[i].SetFocus(true)
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package styles

import (
        "github.com/charmbracelet/lipgloss/v2"
)

// Theme contains all Lipgloss styles for the Shantilly TUI.
// It uses simple colors that work well in most terminals.
type Theme struct {
        // Input styles
        Input        lipgloss.Style
        InputFocused lipgloss.Style
        InputError   lipgloss.Style

        // Label styles
        Label      lipgloss.Style
        LabelError lipgloss.Style

        // Button/Action styles
        Button        lipgloss.Style
        ButtonFocused lipgloss.Style

        // Container styles
        Title       lipgloss.Style
        Description lipgloss.Style
        Help        lipgloss.Style
        Error       lipgloss.Style

        // Layout styles
        Border       lipgloss.Style
        BorderActive lipgloss.Style

        // Component-specific styles
        CheckboxChecked   lipgloss.Style
        CheckboxUnchecked lipgloss.Style
        RadioSelected     lipgloss.Style
        RadioUnselected   lipgloss.Style
        SliderBar         lipgloss.Style
        SliderFilled      lipgloss.Style

        // Tab styles
        TabActive   lipgloss.Style
        TabInactive lipgloss.Style
}

// Color palette
var (
        // Primary colors - Charm purple
        primaryColor = lipgloss.Color("#7D56F4")
        primaryDark  = lipgloss.Color("#5A3FBF")

        // Accent colors
        accentGreen = lipgloss.Color("#04B575")
        accentRed   = lipgloss.Color("#FF0000")
        accentBlue  = lipgloss.Color("#0087D7")

        // Neutral colors
        textPrimary   = lipgloss.Color("#E0E0E0")
        textSecondary = lipgloss.Color("#888888")
        textMuted     = lipgloss.Color("#666666")

        // Background colors
        bgNormal  = lipgloss.Color("#1A1A1A")
        bgFocused = lipgloss.Color("#2D2640")
        bgError   = lipgloss.Color("#3D2020")

        // Border colors
        borderNormal = lipgloss.Color("#404040")
        borderFocus  = lipgloss.Color("#7D56F4")
        borderError  = lipgloss.Color("#FF0000")
)

// DefaultTheme creates a theme using default Lipgloss styles.
func DefaultTheme() *Theme <span class="cov10" title="13">{
        t := &amp;Theme{}

        // Input styles (without borders - borders are applied by layout/form models)
        t.Input = lipgloss.NewStyle().
                Foreground(textPrimary).
                Background(bgNormal).
                Padding(0, 1)

        t.InputFocused = t.Input.
                Background(bgFocused)

        t.InputError = t.Input.
                Background(bgError)

        // Label styles
        t.Label = lipgloss.NewStyle().
                Foreground(textPrimary).
                Bold(true).
                MarginBottom(1)

        t.LabelError = t.Label.
                Foreground(accentRed)

        // Button styles
        t.Button = lipgloss.NewStyle().
                Foreground(textPrimary).
                Background(bgNormal).
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(borderNormal).
                Padding(0, 2).
                MarginRight(2)

        t.ButtonFocused = t.Button.
                Foreground(lipgloss.Color("#FFFFFF")).
                Background(primaryColor).
                BorderForeground(primaryColor).
                Bold(true)

        // Container styles
        t.Title = lipgloss.NewStyle().
                Foreground(primaryColor).
                Bold(true).
                Underline(true).
                MarginBottom(1)

        t.Description = lipgloss.NewStyle().
                Foreground(textSecondary).
                Italic(true).
                MarginBottom(2)

        t.Help = lipgloss.NewStyle().
                Foreground(textMuted).
                Italic(true).
                MarginTop(1)

        t.Error = lipgloss.NewStyle().
                Foreground(accentRed).
                Bold(true).
                MarginTop(1)

        // Layout styles
        t.Border = lipgloss.NewStyle().
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(borderNormal).
                Padding(1, 2)

        t.BorderActive = t.Border.
                BorderForeground(borderFocus)

        // Checkbox styles
        t.CheckboxChecked = lipgloss.NewStyle().
                Foreground(accentGreen).
                Bold(true)

        t.CheckboxUnchecked = lipgloss.NewStyle().
                Foreground(textMuted)

        // Radio styles
        t.RadioSelected = lipgloss.NewStyle().
                Foreground(primaryColor).
                Bold(true)

        t.RadioUnselected = lipgloss.NewStyle().
                Foreground(textPrimary)

        // Slider styles
        t.SliderBar = lipgloss.NewStyle().
                Foreground(borderNormal)

        t.SliderFilled = lipgloss.NewStyle().
                Foreground(primaryColor).
                Bold(true)

        // Tab styles
        t.TabActive = lipgloss.NewStyle().
                Foreground(lipgloss.Color("#FFFFFF")).
                Background(primaryColor).
                Padding(0, 2).
                Bold(true)

        t.TabInactive = lipgloss.NewStyle().
                Foreground(textSecondary).
                Background(bgNormal).
                Padding(0, 2)

        return t
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
